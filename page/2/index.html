<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
<meta property="og:type" content="website">
<meta property="og:title" content="Long">
<meta property="og:url" content="http://royzhao.github.io/page/2/index.html">
<meta property="og:site_name" content="Long">
<meta property="og:description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Long">
<meta name="twitter:description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
  
    <link rel="alternative" href="/atom.xml" title="Long" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">培龙</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/storage/" style="font-size: 20px;">-storage</a> <a href="/tags/HA/" style="font-size: 10px;">HA</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">骚年，你好</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">培龙</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">培龙</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-180" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/30/180/" class="article-date">
  	<time datetime="2015-03-30T07:32:15.000Z" itemprop="datePublished">2015-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/30/180/">docker-browser-server</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>该项目主要使用了普通的http和websocket，下面从http以及websocket两个方面来说一下遇到的坑。</p>
<h2 id=""> </h2><pre><code>先<span class="keyword">http</span>
</code></pre><p>我们的需求主要有如下<br>1)如何对http请求加过滤器（比如在处理用户权限问题上）</p>
<h2 id="-1"> </h2><pre><code>然后websocket
</code></pre><p>websocket的需求主要有如下<br>1)<span>docker服务器</span>如何与浏览器进行通信<br>2)对docker服务器进行操作</p>
<h2 id="-2"> </h2><pre><code>下面我分别诉说一下如何做到这几点
</code></pre><h3 id="-3"> </h3><pre><code><span class="number">1</span>)<span class="keyword">http</span>过滤器
</code></pre><p>在index.js文件之中过滤器相当于找到如下代码<br>&nbsp;</p>
<pre class="brush:javascript">server.all('uri1',function(req, res, next) {
    //做你想做的内容
    console.log('1')
    next()//表示进入到下一个处理
})

server.all('uri1',function(req, res, next) {
    //做你想做的内容
    console.log('2')
    next()//表示进入到下一个处理
})</pre>
&nbsp;
这里面解释如下：
&nbsp;
1\. all方法表示处理所有的url为uri1的http请求（包含get，post等方法），如果你只想处理get方法，那么你可以使用
&nbsp;
<pre class="brush:javascript">server.get('uri1',function(req, res, next) {
    //做你想做的内容
    next()//表示进入到下一个处理
})</pre>
&nbsp;
2.处理的顺序是和申明的顺序一致的
&nbsp;

### 
    2)websocket

#### 
    2.1服务器端与浏览器通信

通过websocket进行通信，服务端代码为
&nbsp;
<pre class="brush:javascript">  var wss = new WebSocketServer({server:server})
  var containers = {}

  wss.on('connection', function(connection) {
    var req = connection.upgradeReq
  })</pre>
&nbsp;
wss就是一个声明好了的websocket服务器，
&nbsp;
<pre class="brush:javascript">wss.on('connection',function(connection){

})</pre>
&nbsp;
这段代码表示ws服务器一旦监听到有客户端连接的事件发生，那么就会执行后面那个函数，入参connection是一个websocket的连接实例，每一个客户端都和服务器有这么一个连接，如果服务器想向客户端发送消息只需要connection.send(.....)就好了。
&nbsp;
然后服务端与浏览器具体怎通信呢？
由于我们是web terminal，主要的目的就是如下
把容器里的标准输出流定位到浏览器里，把浏览器上的标准输入流定位到容器中
作者有一个开源项目叫做pump，来实现这个功能
用法很简单，如下
&nbsp;
<pre class="brush:javascript">var pump = require('pump');
var fs = require('fs');

var source = fs.createReadStream('/dev/random');
var dest = fs.createWriteStream('/dev/null');

pump(source, dest, function(err) {
    console.log('pipe finished', err);
});</pre>
&nbsp;
这上面的代码就是重定向流的代码，把/dev/random里的东西读入，然后放入到/dev/null中，pump的优势在于如果有一方断开了，那么这个管道就自动删除掉了。
&nbsp;
pump更加赞的还有管道连接
&nbsp;
<pre class="brush:javascript">pump(source, transform, anotherTransform, dest, function(err) {
    console.log('pipe finished', err);
});</pre>
&nbsp;
这段代码的意思是把source输入到transform中，然后把transform流输入到anotherTransform里面，
&nbsp;
查看index.js的代码有这么一段
&nbsp;
<pre class="brush:javascript">                    pump(stream, docker(image, dopts), stream, function(err) {
                        console.log('error in create docker');
                        console.log(err);
                        if (proxy) proxy.close()
                        server.emit('kill', container)
                        delete containers[id]
                    })</pre>
&nbsp;
&nbsp;
stream就是服务器端和浏览器建立的连接的管道，
docker(image.dopts)创建了个服务器与docker服务器之间的管道
这里的意思就是stream的输出定位到服务器与的docker服务器建立的管道中，然后又把这个管道里面的流定位到stream的输入里来，这样就完成了浏览器与docker容器的交互

#### 
    2.2对docker服务器进行操作

    目前只有create镜像，attach镜像，pull镜像三个功能，都在docker_run这个模块中实现。

    现在我以pull镜像为例子，在docker-run里面代码如下

<pre class="brush:javascript">  var pull = function(cb){
      console.log('pull image')

      debug('pulling to stdio for %s', image)
      request.post('/images/create?fromImage='+image, {
      }, function(err, response) {
           //处理docker服务器返回的数据
      })
  }</pre>

<pre><code>&amp;nbsp<span class="comment">;使用方法如下</span>
</code></pre><pre class="brush:javascript">pull(function(xx){
     //处理回调
})</pre>

<pre><code>&amp;nbsp<span class="comment">;那么在哪儿调用呢？</span>

比如我有一个api是只pull镜像的
</code></pre><pre class="brush:bash">/image/{userid}/pull/{imagename}</pre>

<pre><code>&amp;nbsp;那么我就要在docker-browser-<span class="keyword">server</span>里面增加一个url处理的函数来处理这个api
</code></pre><pre class="brush:javascript">  server.get('/image{userid}/pull/{imagename}',function(req,res){
        var id = req.params.userid
        var image = req.params.imagename
        var container = containers.hasOwnProperty(id) &amp;&amp; containers[id]
        if (container){
             //只让正在使用终端的用户进行pull代码
            container.docker_run.pull(image)
        }
    })</pre>

<pre><code>&amp;nbsp;pull的代码该怎么写呢？在docker-<span class="command">run</span>的index.js中如下
</code></pre><pre class="brush:javascript">that.pull = function(image){
// pull image
}</pre>

<pre><code>好了，我们的代码将完了

docker-browser-<span class="keyword">server</span>的代码这么执行&amp;nbsp;
</code></pre><pre class="brush:javascript">git clone https://github.com/royzhao/docker-browser-server.git
cd docker-browser-server
npm install
cd node_modules
rm -rf docker-browser-console
git clone https://github.com/royzhao/docker-browser-console.git
cd docker-browser-console
npm install
cd node_modules
rm -rf docker-run
git clone https://github.com/royzhao/docker-run.git
cd docker-run
npm install</pre>

<pre><code>&amp;nbsp<span class="comment">;</span>
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-ubuntu14-04-e5-8d-b8-e8-bd-bd-e8-be-93-e5-85-a5-e6-b3-95-e5-90-8e-e5-be-aa-e7-8e-af-e7-99-bb-e5-bd-95-e4-b8-80-e7-9b-b4-e8-b7-b3-e5-88-b0-e7-99-bb-e5-bd-95-e7-95-8c-e9-9d-a2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/30/ubuntu14-04-e5-8d-b8-e8-bd-bd-e8-be-93-e5-85-a5-e6-b3-95-e5-90-8e-e5-be-aa-e7-8e-af-e7-99-bb-e5-bd-95-e4-b8-80-e7-9b-b4-e8-b7-b3-e5-88-b0-e7-99-bb-e5-bd-95-e7-95-8c-e9-9d-a2/" class="article-date">
  	<time datetime="2015-03-30T00:04:23.000Z" itemprop="datePublished">2015-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/30/ubuntu14-04-e5-8d-b8-e8-bd-bd-e8-be-93-e5-85-a5-e6-b3-95-e5-90-8e-e5-be-aa-e7-8e-af-e7-99-bb-e5-bd-95-e4-b8-80-e7-9b-b4-e8-b7-b3-e5-88-b0-e7-99-bb-e5-bd-95-e7-95-8c-e9-9d-a2/">UBUNTU14.04 卸载输入法后循环登录一直跳到登录界面</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自<a href="http://ijuer.cn/blog/313.html" target="_blank" rel="external">http://ijuer.cn/blog/313.html</a></p>
<pre><code>今天看到 <span class="tag">Ubuntu</span> 下期待已久的搜狗拼音输入法更新到了 1<span class="class">.2</span> 版本，就激动的下载安装了，谁知安装后还是各种的不爽，接着就卸载了，一并卸载了&amp;<span class="tag">nbsp</span>;<span class="tag">fcitx</span> ，重启完机器后。。。。。。。。问题来了。

在登录界面输入正确的用户名和密码，显示器黑屏一下，然后重新跳转回登录界面。重启无效。一直循环在登录界面。

通过在网上查找。发现这个问题有不少人遇到，但是都没有真正的解决问题，大家说的最多的造成该情况的原因是 主目录下的<span class="class">.Xauthority</span>文件拥有者变成了<span class="tag">root</span>，从而以用户登陆的时候无法都取<span class="class">.Xauthority</span>文件。

解决方法是将<span class="class">.Xauthority</span>的拥有者改为登陆用户（或者干脆将<span class="class">.Xauthority</span>删除）

步骤：
</code></pre><p>开机后在登陆界面按下shift + ctrl + F1进入tty命令行终端登陆后输入：</p>
<pre>$ cd ~</pre>
<pre>$ sudo chown user:user .Xauthority (注：user为要登录的用户名)</pre>
<pre>ls .Xauthority -l</pre>
<pre>-rw------- 1 user user 80 &nbsp;1月 27 10:41 .Xauthority</pre>

<pre><code>此时拥有者已经变为用户。按下shift + ctrl + <span class="literal">F7</span>切换回图形登陆界面登陆即可。

在本人满怀欣喜的按照步骤操作之后，发现，问题果然没有解决。看来不是 Xauthority 的原因！

由于是卸载完搜狗拼音和 fcitx 后出现的问题，感觉一定和 fcitx 有一定的关系，应该是没卸载干净，或者在卸载 fcitx 的时候误删了 ibus 的配置，然后决定按照推测试一下，执行命令：
</code></pre><pre>dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P</pre>

<pre><code>该命令为清除所有已删除包的残馀配置文件，发现果然有 fcitx 的残馀配置文件被清除，然后重启系统，输入密码，问题果然解决！！！

最后提醒大家：输入法有风险，安装需谨慎！！！
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-http-e5-8d-8f-e8-ae-ae" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/19/http-e5-8d-8f-e8-ae-ae/" class="article-date">
  	<time datetime="2015-01-19T04:00:45.000Z" itemprop="datePublished">2015-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/http-e5-8d-8f-e8-ae-ae/">http协议</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Quick_reminder_about_HTTP">Quick reminder about HTTP</h1><div><br><pre>When haproxy is running in HTTP mode, both the request and the response are<br>fully analyzed and indexed, thus it becomes possible to build matching criteria<br>on almost anything found in the contents.</pre><br><pre>当haproxy运行在HTTP mode的时候，它会把所有的响应以及请求都会分析和建索引，这样才能够让匹配内容中的关键信息成为可能</pre><br><pre>However, it is important to understand how HTTP requests and responses are<br>formed, and how HAProxy decomposes them. It will then become easier to write<br>correct rules and to debug existing configurations.</pre><br><pre>然后，我们需要要理解http的请求和响应的格式记忆haproxy是如何解析他们的，这样我们才能更加正确和简便的写出正确的规则以及调试现有的配置文件</pre><br></div><br><a id="1.1" name="1.1"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.1" target="_blank" rel="external">1.1.</a></small> The HTTP transaction model<br><br><div><br><pre>The HTTP protocol is transaction-driven. This means that each request will lead<br>to one and only one response. Traditionally, a TCP connection is established<br>from the client to the server, a request is sent by the client on the<br>connection, the server responds and the connection is closed. A new request<br>will involve a new connection :<br><br>  [CON1] [REQ1] … [RESP1] [CLO1] [CON2] [REQ2] … [RESP2] [CLO2] …<br><br>In this mode, called the “HTTP close” mode, there are as many connection<br>establishments as there are HTTP transactions. Since the connection is closed<br>by the server after the response, the client does not need to know the content<br>length.</pre><br><pre>http协议时事物驱动的，这意味这每一个请求都会导致有且仅有一个响应。一般来说，一个TCP链接是客户端和服务器之间建立的双向链接，一个客户端的请求在这个链路上被发送，服务器会返回一个响应，然后关闭这个链接，一个请求就会有一个新的链接，就如下一样</pre><br><pre>  [CON1] [REQ1] … [RESP1] [CLO1] [CON2] [REQ2] … [RESP2] [CLO2] …</pre><br><pre>这种模式叫做“HTTP close”模式，当HTTP事物开始的时候会建立很多次的链接。当服务器返回请求后链接被其关闭客户端并不需要知道内容的长度。</pre><br><pre>Due to the transactional nature of the protocol, it was possible to improve it<br>to avoid closing a connection between two subsequent transactions. In this mode<br>however, it is mandatory that the server indicates the content length for each<br>response so that the client does not wait indefinitely. For this, a special<br>header is used: “Content-length”. This mode is called the “keep-alive” mode :<br><br>  [CON] [REQ1] … [RESP1] [REQ2] … [RESP2] [CLO] …</pre><br><pre>根据这种协议的特性，我们可以在两次连续的事物之间避免关闭tcp链接来提升性能。在这种模式下，必须让服务器强制性的设定每个响应的内容长度，这样才能让客户端无限制的等待。为了达到这个目标，一个特殊的头将会被用到“Content-length”。这个模式叫做“keep-alive”模式</pre><br><pre>  [CON] [REQ1] … [RESP1] [REQ2] … [RESP2] [CLO] …</pre><br><pre>Its advantages are a reduced latency between transactions, and less processing<br>power required on the server side. It is generally better than the close mode,<br>but not always because the clients often limit their concurrent connections to<br>a smaller value.</pre><br><pre>keep-alive模式效的减少了两个事物之间的延迟，且可以让服务器提升性能，一般情况下这种模式比close模式好很多，但也不是总是，因为客户端经常会限制并发连接数在一个很小的值上。<br><br>A last improvement in the communications is the pipelining mode. It still uses<br>keep-alive, but the client does not wait for the first response to send the<br>second request. This is useful for fetching large number of images composing a<br>page :<br><br>  [CON] [REQ1] [REQ2] … [RESP1] [RESP2] [CLO] …</pre><br><pre>为了解决这个问题，我们可以使用一种叫做pipelining的模式，它使用了keep-alive，客户端在发送第二个请求的时候就不需要等待第一个请求的响应了。这个在其请求页面上有大量的图片的时候很有用。</pre><br><pre>This can obviously have a tremendous benefit on performance because the network<br>latency is eliminated between subsequent requests. Many HTTP agents do not<br>correctly support pipelining since there is no way to associate a response with<br>the corresponding request in HTTP. For this reason, it is mandatory for the<br>server to reply in the exact same order as the requests were received.<br>这明显在性能上有明显的提升，因为连个请求之间的网络延迟被消灭了。许多http代理不能正确的支持pipelining，因为他们没有办法把响应和正确的请求联系起来。因为这个原因，服务器必须按照请求的顺序进行响应。</pre><br><pre>By default HAProxy operates in keep-alive mode with regards to persistent<br>connections: for each connection it processes each request and response, and<br>leaves the connection idle on both sides between the end of a response and the<br>start of a new request.</pre><br><pre>haproxy默认使用的时keep-alive的模式：对于每一个链接，它接受一个请求就处理一个请求，链接会在结束响应之后和新开始一个请求之间的时间内处于空闲。</pre><br><pre>HAProxy supports 5 connection modes :<br>  - keep alive    : all requests and responses are processed (default)<br>  - tunnel        : only the first request and response are processed,<br>                    everything else is forwarded with no analysis.<br>  - passive close : tunnel with “Connection: close” added in both directions.<br>  - server close  : the server-facing connection is closed after the response.<br>  - forced close  : the connection is actively closed after end of response.</pre><br><pre>haproxy支持5种链接模式</pre><br><pre>-keep alive:所已有的请求和响应都会被处理</pre><br><pre>-tunnel     :只有第一个请求和响应会被处理，其余的直接转发，不会被分析</pre><br><pre>-passive close：tunnel with “connection：close” added in both directions</pre><br><pre>-server close：the server-facing connection is closed after the response.</pre><br><pre>-forced close：在响应结束后链接会被关闭</pre><br></div><br><a id="1.2" name="1.2"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2" target="_blank" rel="external">1.2.</a></small> HTTP request<br><br><div><br><pre>First, let’s consider this HTTP request :<br><br>  Line     Contents<br>  number<br>     1     GET /serv/login.php?lang=en&amp;profile=2 HTTP/1.1<br>     2     Host: www.mydomain.com<br>     3     User-agent: my small browser<br>     4     Accept: image/jpeg, image/gif<br>     5     Accept: image/png</pre><br><pre>首先，我们来考虑下HTTP请求：</pre><br><pre>  Line     Contents<br>  number<br>     1     GET /serv/login.php?lang=en&amp;profile=2 HTTP/1.1<br>     2     Host: www.mydomain.com<br>     3     User-agent: my small browser<br>     4     Accept: image/jpeg, image/gif<br>     5     Accept: image/png</pre><br></div><br><a id="1.2.1" name="1.2.1"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2.1" target="_blank" rel="external">1.2.1.</a></small> The Request line<br><br><div><br><pre>Line 1 is the “request line”. It is always composed of 3 fields :<br>第一行时请求行，一般由三个部分组成<br>  - a METHOD      : GET<br>  - a URI         : /serv/login.php?lang=en&amp;profile=2<br>  - a version tag : HTTP/1.1<br><br>All of them are delimited by what the standard calls LWS (linear white spaces),<br>which are commonly spaces, but can also be tabs or line feeds/carriage returns<br>followed by spaces/tabs. The method itself cannot contain any colon (‘:’) and<br>is limited to alphabetic letters. All those various combinations make it<br>desirable that HAProxy performs the splitting itself rather than leaving it to<br>the user to write a complex or inaccurate regular expression.<br>这些都被叫做LWS（Linear white spaces，其实一般就是空格）的标准分割开。</pre><br><pre>方法：不能有任何的冒号，它被限制在字母表中的字符。</pre><br><pre>所有的这些不同组合在一起，可以让haproxy分析它，而不是让用户写复杂的正则表达式。</pre><br><pre>The URI itself can have several forms :<br><br>  - A “relative URI” :<br><br>      /serv/login.php?lang=en&amp;profile=2<br><br>    It is a complete URL without the host part. This is generally what is<br>    received by servers, reverse proxies and transparent proxies.<br><br>  - An “absolute URI”, also called a “URL” :<br><br>      <a href="http://192.168.0.12:8080/serv/login.php?lang=en&amp;profile=2" target="_blank" rel="external">http://192.168.0.12:8080/serv/login.php?lang=en&amp;profile=2</a><br><br>    It is composed of a “scheme” (the protocol name followed by ‘://‘), a host<br>    name or address, optionally a colon (‘:’) followed by a port number, then<br>    a relative URI beginning at the first slash (‘/‘) after the address part.<br>    This is generally what proxies receive, but a server supporting HTTP/1.1<br>    must accept this form too.<br>URI：有两种格式</pre><br><pre>第一种时相对路径的URI，如下</pre><br><pre>/serv/login.php?lang=en&amp;profile=2</pre><br><pre>这种是不需要域名部分的，这一般都是服务器/反向代理/透明代理接受到的样子</pre><br><pre>还有一种时绝对路径叫做URL，如下</pre><br><pre><a href="http://xxx.com/serv/login.php?lang=en&amp;profile=2" target="_blank" rel="external">http://xxx.com/serv/login.php?lang=en&amp;profile=2</a></pre><br><pre>这被一个scheme压缩（协议名字在://前面）</pre><br><pre>  - a star (‘*’) : this form is only accepted in association with the OPTIONS<br>    method and is not relayable. It is used to inquiry a next hop’s<br>    capabilities.<br><br>  - an address:port combination : 192.168.0.12:80<br>    This is used with the CONNECT method, which is used to establish TCP<br>    tunnels through HTTP proxies, generally for HTTPS, but sometimes for<br>    other protocols too.<br><br>In a relative URI, two sub-parts are identified. The part before the question<br>mark is called the “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#path" target="_blank" rel="external">path</a>“. It is typically the relative path to static objects<br>on the server. The part after the question mark is called the “query string”.<br>It is mostly used with GET requests sent to dynamic scripts and is very<br>specific to the language, framework or application in use.</pre><br></div><br><a id="1.2.2" name="1.2.2"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2.2" target="_blank" rel="external">1.2.2.</a></small> The request headers<br><br><div><br><pre>The headers start at the second line. They are composed of a name at the<br>beginning of the line, immediately followed by a colon (‘:’). Traditionally,<br>an LWS is added after the colon but that’s not required. Then come the values.<br>Multiple identical headers may be folded into one single line, delimiting the<br>values with commas, provided that their order is respected. This is commonly<br>encountered in the “Cookie:” field. A header may span over multiple lines if<br>the subsequent lines begin with an LWS. In the example in 1.2, lines 4 and 5<br>define a total of 3 values for the “Accept:” header.</pre><br><pre>请求头从第二行开始，都是由一个语法时name: value1,value2<br><br>Contrary to a common mis-conception, header names are not case-sensitive, and<br>their values are not either if they refer to other header names (such as the<br>“Connection:” header).</pre><br><pre>http头的名字都不是大小写敏感的，当它的值引用其他的头的名字时，也不大小写敏感</pre><br><pre>The end of the headers is indicated by the first empty line. People often say<br>that it’s a double line feed, which is not exact, even if a double line feed<br>is one valid form of empty line.<br>头的结束时有一个空的行来表示</pre><br><pre>Fortunately, HAProxy takes care of all these complex combinations when indexing<br>headers, checking values and counting them, so there is no reason to worry<br>about the way they could be written, but it is important not to accuse an<br>application of being buggy if it does unusual, valid things.<br>幸运的时，haprxy对这些复杂的组合都会认证的建索引，检查值和对他们进行计数。<br>Important note:<br>   As suggested by RFC2616, HAProxy normalizes headers by replacing line breaks<br>   in the middle of headers by LWS in order to join multi-line headers. This<br>   is necessary for proper analysis and helps less capable HTTP parsers to work<br>   correctly and not to be fooled by such complex constructs.</pre><br></div><br><a id="1.3" name="1.3"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3" target="_blank" rel="external">1.3.</a></small> HTTP response<br><br><div><br><pre>An HTTP response looks very much like an HTTP request. Both are called HTTP<br>messages. Let’s consider this HTTP response :<br>一个http响应比较像http的请求，都叫做http消息<br>  Line     Contents<br>  number<br>     1     HTTP/1.1 200 OK<br>     2     Content-length: 350<br>     3     Content-Type: text/html<br><br>As a special case, HTTP supports so called “Informational responses” as status<br>codes 1xx. These messages are special in that they don’t convey any part of the<br>response, they’re just used as sort of a signaling message to ask a client to<br>continue to post its request for instance. In the case of a status 100 response<br>the requested information will be carried by the next non-100 response message<br>following the informational one. This implies that multiple responses may be<br>sent to a single request, and that this only works when keep-alive is enabled<br>(1xx messages are HTTP/1.1 only). HAProxy handles these messages and is able to<br>correctly forward and skip them, and only process the next non-100 response. As<br>such, these messages are neither logged nor transformed, unless explicitly<br>state otherwise. Status 101 messages indicate that the protocol is changing<br>over the same connection and that haproxy must switch to tunnel mode, just as<br>if a CONNECT had occurred. Then the Upgrade header would contain additional<br>information about the type of protocol the connection is switching to.</pre><br></div><br><a id="1.3.1" name="1.3.1"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3.1" target="_blank" rel="external">1.3.1.</a></small> The Response line<br><br><div><br><pre>Line 1 is the “response line”. It is always composed of 3 fields :<br><br>  - a version tag : HTTP/1.1<br>  - a status code : 200<br>  - a reason      : OK<br><br>The status code is always 3-digit. The first digit indicates a general status :<br> - 1xx = informational message to be skipped (eg: 100, 101)<br> - 2xx = OK, content is following   (eg: 200, 206)<br> - 3xx = OK, no content following   (eg: 302, 304)<br> - 4xx = error caused by the client (eg: 401, 403, 404)<br> - 5xx = error caused by the server (eg: 500, 502, 503)<br><br>Please refer to RFC2616 for the detailed meaning of all such codes. The<br>“reason” field is just a hint, but is not parsed by clients. Anything can be<br>found there, but it’s a common practice to respect the well-established<br>messages. It can be composed of one or multiple words, such as “OK”, “Found”,<br>or “Authentication Required”.<br><br>Haproxy may emit the following status codes by itself :<br><br>  Code  When / reason<br>   200  access to stats page, and when replying to monitoring requests<br>   301  when performing a redirection, depending on the configured code<br>   302  when performing a redirection, depending on the configured code<br>   303  when performing a redirection, depending on the configured code<br>   307  when performing a redirection, depending on the configured code<br>   308  when performing a redirection, depending on the configured code<br>   400  for an invalid or too large request<br>   401  when an authentication is required to perform the action (when<br>        accessing the stats page)<br>   403  when a request is forbidden by a “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#block" target="_blank" rel="external">block</a>“ ACL or “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#reqdeny" target="_blank" rel="external">reqdeny</a>“ filter<br>   408  when the request timeout strikes before the request is complete<br>   500  when haproxy encounters an unrecoverable internal error, such as a<br>        memory allocation failure, which should never happen<br>   502  when the server returns an empty, invalid or incomplete response, or<br>        when an “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#rspdeny" target="_blank" rel="external">rspdeny</a>“ filter blocks the response.<br>   503  when no server was available to handle the request, or in response to<br>        monitoring requests which match the “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#monitor%20fail" target="_blank" rel="external">monitor fail</a>“ condition<br>   504  when the response timeout strikes before the server responds<br><br>The error 4xx and 5xx codes above may be customized (see “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#errorloc" target="_blank" rel="external">errorloc</a>“ in section<br>4.2).</pre><br></div><br><a id="1.3.2" name="1.3.2"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3.2" target="_blank" rel="external">1.3.2.</a></small> The response headers<br><br><div><br><pre>Response headers work exactly like request headers, and as such, HAProxy uses<br>the same parsing function for both. Please refer to paragraph 1.2.2 for more<br>details.</pre><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a><a class="article-category-link" href="/categories/未分类/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-haproxy-e7-ae-80-e5-8d-95-e4-bd-bf-e7-94-a8http-e7-bf-bb-e8-af-91-e8-87-aadigitalocean" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/16/haproxy-e7-ae-80-e5-8d-95-e4-bd-bf-e7-94-a8http-e7-bf-bb-e8-af-91-e8-87-aadigitalocean/" class="article-date">
  	<time datetime="2015-01-16T14:14:07.000Z" itemprop="datePublished">2015-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/16/haproxy-e7-ae-80-e5-8d-95-e4-bd-bf-e7-94-a8http-e7-bf-bb-e8-af-91-e8-87-aadigitalocean/">haproxy简单使用http-翻译自digitalocean</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文链接：<a href="https://www.digitalocean.com/community/tutorials/how-to-use-haproxy-to-set-up-http-load-balancing-on-an-ubuntu-vps" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-use-haproxy-to-set-up-http-load-balancing-on-an-ubuntu-vps</a></p>
<h2 id="准备工作">准备工作</h2><p>3个节点</p>
<p>1. node1</p>
<p>hostname:haproxy</p>
<p>os：ubuntu</p>
<p>ip:10.0.0.100</p>
<p>2.node2</p>
<p>hostname lamp1</p>
<p>ip:10.0.0.1</p>
<p>3.node3</p>
<p>hostname lamp2</p>
<p>ip:10.0.0.2</p>
<h2 id="安装HAProxy">安装HAProxy</h2><p>1.直接使用apt-get安装</p>
<blockquote>
<p>apt-get install haproxy<br>2.安装完成之后，我们打开/etc/default/haproxy把ENABLED设置为1</p>
</blockquote>
<h2 id="配置HAProxy">配置HAProxy</h2><p>1.进入到/etc/haproxy里新建haproxy.cfg</p>
<p>2.打开haproxy.cfg，我们一部分一部分的向里面加入</p>
<p>2.1 首先加入如下配置</p>
<blockquote>
<p>global</p>
<p>log 127.0.0.1 local0 notice</p>
<p>maxconn 2000</p>
<p>user haproxy</p>
<p>group haproxy</p>
</blockquote>
<p>log指令的意思是告诉haproxy把系统日志发送到哪一台的syslog服务器，ubuntu里面的sysslog当然是运行着的，但是它没有绑定任何ip地址，我们将会在后面修改rsyslog的配置文件</p>
<p>maxconn的意思当然时说明了同一时间最大的连接数了，这个数字可以随便改</p>
<p>user和group是给正在运行haproxy进程的制定用户和用户组，这个就不要改变他了</p>
<p>2.2 然后加入defaluts块</p>
<blockquote>
<p>defaluts</p>
<p>log global</p>
<p>mode http</p>
<p>option httplog</p>
<p>option dontlognull</p>
<p>retries 3</p>
<p>option redispath</p>
<p>timeout connect 5000</p>
<p>timeout client 10000</p>
<p>timeout server 10000</p>
</blockquote>
<p>在这个块里，我们指定了默认的值。</p>
<p>timeout connect选项指定了最大的连接时间</p>
<p>timeout client和server设置的值表示如果服务器或者客户端在这段时间没有进行任何tcp处理，那么将会被断开，HAProxy推荐两个使用相同的值</p>
<p>retries指令用来设置重连的次数</p>
<p>option redispatch会开启当链接断掉的时候重分发session，所以如果后面的服务挂掉了，session粘滞不会存在。</p>
<p>2.3 下面配置listen</p>
<blockquote>
<p>listen appname 0.0.0.0:80</p>
<p>mode http</p>
<p>stats enable</p>
<p>stats uri /haproxy?stats</p>
<p>stats realm Strictly\ Private</p>
<p>stats auth A_Username:YourPassword</p>
<p>stats auth Another_User:passwd</p>
<p>balance roundrobin</p>
<p>option httpclose</p>
<p>option forwardfor</p>
<p>server lamp1 10.0.0.1:80 check</p>
<p>server lamp2 10.0.0.2:80 check</p>
</blockquote>
<p>这里包含了前端和后端的配置，我们配置haproxy为appname监听80端口，appname仅仅是个用来区分引用的名字。</p>
<p>stats指令用来开启连接状态统计页面，这个通过<a href="https://www.digitalocean.com/community/articles/how-to-set-up-http-authentication-with-nginx-on-ubuntu-12-10" target="_blank" rel="external">HTTP Basic authentication</a>保证安全，它时stats auth指定的</p>
<p>stats uri就是这个统计页面的url地址</p>
<p>balance指令指定了一个负载均衡算法，可以有的选项有roundrobin/static-rr/leastconn/source/uri/url_param</p>
<p>server指令时来申明一个后端服务器，语法如下</p>
<blockquote>
<p>server &lt;name&gt; &lt;address&gt;[:port] [param*]</p>
</blockquote>
<p>name主要是写入日志用，方便我们跟踪日志，<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.4.html#5" target="_blank" rel="external">这里有更多的参数</a>，在这篇文章中我们只使用check和cookie这两个参数</p>
<p>check参数时开启健康检查，检查服务器是否正常</p>
<p>2.4 好了，我们现在配置好了可以使用下面的命令开启它</p>
<blockquote>
<p>service haproxy start</p>
</blockquote>
<h2 id="测试负载均衡">测试负载均衡</h2><p>1.创建php文件打印处服务器ip和客户端ip</p>
<p>&nbsp;</p>
<blockquote>
<p>&lt;?php header(‘Content-Type: text/plain’); `</p>
<pre><code>&lt;<span class="keyword">pre</span>&gt;`<span class="keyword">echo</span> <span class="string">"Server IP: "</span>.$_SERVER[<span class="string">'SERVER_ADDR'</span>]; `&lt;/<span class="keyword">pre</span>&gt;

&lt;<span class="keyword">pre</span>&gt;`<span class="keyword">echo</span> <span class="string">"\nClient IP: "</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>];`&lt;/<span class="keyword">pre</span>&gt;

&lt;<span class="keyword">pre</span>&gt;` <span class="keyword">echo</span> <span class="string">"\nX-Forwarded-for: "</span>.$_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>]; `&lt;/<span class="keyword">pre</span>&gt;

&lt;<span class="keyword">pre</span>&gt;`?&amp;gt;`&lt;/<span class="keyword">pre</span>&gt;
&lt;<span class="keyword">pre</span>&gt;`我们访问haproxy所在的ip地址`&lt;/<span class="keyword">pre</span>&gt;
&lt;<span class="keyword">pre</span>&gt;`第一次访问`&lt;/<span class="keyword">pre</span>&gt;
</code></pre><p>Server IP: 172.17.0.5</p>
<pre><code><span class="title">Client</span> IP: <span class="number">172.17.0.3</span>

X-Forwarded-for: <span class="number">172.17.42.1</span>
第二次访问
</code></pre><p>Server IP: 172.17.0.4</p>
<pre><code><span class="title">Client</span> IP: <span class="number">172.17.0.3</span>

X-Forwarded-for: <span class="number">172.17.42.1</span>
&lt;span style=<span class="string">"color: #ff0000;"</span>&gt;注：我没有多个机器，所以我使用的docker容器来做实验，这个是我自己跑出来的结果&lt;/span&gt;
</code></pre></blockquote>
<pre><code>从上面我们看到<span class="tag">haproxy</span>轮番的把我们的请求放到两个后端服务器上，<span class="tag">X-Forwarded-for</span>是你自己客户端

2.模拟服务器挂掉的情况

我们现在模拟服务器挂掉，首先把一个服务关掉，我关掉172<span class="class">.17</span><span class="class">.0</span><span class="class">.4</span>的服务
&gt; <span class="tag">service</span> <span class="tag">apache2</span> <span class="tag">stop</span>
继续访问

连续访问两次都是如下结果
&gt; <span class="tag">Server</span> <span class="rule"><span class="attribute">IP</span>:<span class="value"> <span class="number">172.17</span>.<span class="number">0.5</span></span></span>
</code></pre><blockquote>
<pre><code><span class="title">Client</span> IP: <span class="number">172.17.0.3</span>

X-Forwarded-for: <span class="number">172.17.42.1</span>
我们达到了服务负载和容错的功能
</code></pre></blockquote>
<pre><code>## Session Stickness

如果拟的web应用需要用户登陆（就是你的服务使用到了session），这种负载均衡可能就会遇到问题，因为session是和具体的服务器相关的，haproxy会把用户随机搞到不同的服务器上，服务器就带状态了，就不好搞成分布式了，如果是这种需求，那么我们必须保证用户会被分配到他第一次访问的服务器上去，不然就会乱套，haproxy可以通过设置cookie来标记所使用的服务器来达到这种效果。

下面我们增加一个session.php文件来阐述下这个是如何工作的
&gt; &lt;<span class="keyword">pre</span>&gt;`&amp;<span class="keyword">lt</span>;?php header(<span class="string">'Content-Type: text/plain'</span>); `&lt;/<span class="keyword">pre</span>&gt;
</code></pre><blockquote>
<pre><code><span class="variable">&lt;pre&gt;</span>`session_start(); `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`if(!isset(<span class="variable">$_SESSION</span>['visit'])) { `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`echo <span class="string">"This is the first time you're visiting this server"</span>; `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`<span class="variable">$_SESSION</span>['visit'] = <span class="number">0</span>; `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`} `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`else `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`echo <span class="string">"Your number of visits: "</span>.<span class="variable">$_SESSION</span>['visit']; `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`<span class="variable">$_SESSION</span>['visit']++; echo <span class="string">"\nServer IP: "</span>.<span class="variable">$_SERVER</span>['SERVER_ADDR']; `<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>`echo <span class="string">"\nClient IP: "</span>.<span class="variable">$_SERVER</span>['REMOTE_ADDR']; echo <span class="string">"\nX-Forwarded-for: "</span>.<span class="variable">$_SERVER</span>['HTTP_X_FORWARDED_FOR'].<span class="string">"\n"</span>; print_r(<span class="variable">$_COOKIE</span>);`<span class="variable">&lt;/pre&gt;</span>

<span class="variable">&lt;pre&gt;</span>` ?&amp;gt;`<span class="variable">&lt;/pre&gt;</span>
<span class="variable">&lt;pre&gt;</span>`上面的代码就在apache的服务器上对用户增加了session，会记录你使用这个session多少次`<span class="variable">&lt;/pre&gt;</span>
<span class="variable">&lt;pre&gt;</span>`下面，我们就要使用haproxy在cookie中增加我们的东西了`<span class="variable">&lt;/pre&gt;</span>
<span class="variable">&lt;pre&gt;</span>`我们默认所有到haproxy的请求在http头里都包含set-cookie的字段，我们在这里面存服务器信息`<span class="variable">&lt;/pre&gt;</span>
<span class="variable">&lt;pre&gt;</span>第一步就是在配置文件中，在listen块的下面增加cookie指令<span class="variable">&lt;/pre&gt;</span>
</code></pre><pre>`cookie SRVNAME insert `</pre>

<pre><code>&lt;pre&gt;`server lam<span class="variable">p1</span> 10.0.0.1:80 cookie S1<span class="instruction"> check </span>`&lt;/pre&gt;

&lt;pre&gt;`server lam<span class="variable">p2</span> 10.0.0.2:80 cookie S2 check`&lt;/pre&gt;
&lt;pre&gt;`我们重启haproxy`&lt;/pre&gt;
&lt;pre&gt;`下面使用curl访问`&lt;/pre&gt;
</code></pre><pre>`curl -i http://172.17.0.3/session.php
<pre><span style="font-family: monospace;">结果如下</span></pre>
<pre></pre>
HTTP/1.1 200 OK

Date: Fri, 16 Jan 2015 14:12:00 GMT

Server: Apache/2.4.7 (Ubuntu)

X-Powered-By: PHP/5.5.9-1ubuntu4.5

Set-Cookie: PHPSESSID=q29dmd1eusk0gs1ja9qcq0paj5; path=/

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Vary: Accept-Encoding

Content-Length: 134

Connection: close

Content-Type: text/plain

Set-Cookie: SRVNAME=S1; path=/


This is the first time you're visiting this server

Server IP: 172.17.0.4

Client IP: 172.17.0.3

X-Forwarded-for: 172.17.42.1

Array

(

)
<pre><span style="font-family: monospace;">这个时第一次访问，为了看到我们刚刚的SRVNAME=S1，我们把上面的Set-cookies的头作为参数访问加入SRVNAME=S1（当然你要是浏览器，可以F12召唤神兽直接看）</span></pre>
<pre><span style="font-family: monospace;">curl -i http://172.17.0.3/session.php --cookie "PHPSESSID=0juvu9ir7bvm4agiivfc5pvg11; SRVNAME=S1"</span></pre>
<pre><span style="font-family: monospace;">结果如下</span></pre>
<pre></pre>
HTTP/1.1 200 OK

Date: Fri, 16 Jan 2015 14:12:15 GMT

Server: Apache/2.4.7 (Ubuntu)

X-Powered-By: PHP/5.5.9-1ubuntu4.5

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Vary: Accept-Encoding

Content-Length: 174

Connection: close

Content-Type: text/plain


Your number of visits: 1

Server IP: 172.17.0.4

Client IP: 172.17.0.3

X-Forwarded-for: 172.17.42.1

Array

(

 [PHPSESSID] =&gt; q29dmd1eusk0gs1ja9qcq0paj5

 [SRVNAME] =&gt; S1

)


&nbsp;
<pre><span style="font-family: monospace;">在执行一下</span></pre>
<pre></pre>
HTTP/1.1 200 OK

Date: Fri, 16 Jan 2015 14:12:18 GMT

Server: Apache/2.4.7 (Ubuntu)

X-Powered-By: PHP/5.5.9-1ubuntu4.5

Expires: Thu, 19 Nov 1981 08:52:00 GMT

Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0

Pragma: no-cache

Vary: Accept-Encoding

Content-Length: 174

Connection: close

Content-Type: text/plain


Your number of visits: 2

Server IP: 172.17.0.4

Client IP: 172.17.0.3

X-Forwarded-for: 172.17.42.1

Array

(

 [PHPSESSID] =&gt; q29dmd1eusk0gs1ja9qcq0paj5

 [SRVNAME] =&gt; S1

)


&nbsp;
<pre><span style="font-family: monospace;">可以看到我们解决了这个Session strickness</span></pre></pre></blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/05/ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac/" class="article-date">
  	<time datetime="2014-09-05T06:23:36.000Z" itemprop="datePublished">2014-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/05/ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac/">ld链接脚本(转)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""><div id="cnblogs_post_body"></div></h1><p>转自:<a href="http://www.cnblogs.com/Neddy/archive/2011/12/18/2291576.html" target="_blank" rel="external">http://www.cnblogs.com/Neddy/archive/2011/12/18/2291576.html</a><br>================================== <strong>我 们对每个c或者汇编文件进行单独编译，但是不去连接，生成很多.o 的文件，这些.o文件首先是分散的，我们首先要考虑的如何组合起来；其次，这些.o文件存在相互调用的关系；再者，我们最后生成的bin文件是要在硬件中 运行的，每一部分放在什么地址都要有仔细的说明。我觉得在写makefile的时候，最为重要的就是ld的理解，下面说说我的经验：</strong> <strong>首先，要确定我们的程序用没有用到标准的c库，或者一些系统的库文件，这些一般是在操作系统之上开发要注意的问题，这里并不多说，熟悉在Linux编程的人，基本上都会用ld命令；这里，我们从头开始,直接进行汇编语言的连接。</strong> <strong>我们写一个汇编程序，控制GPIO，从而控制外接的LED，代码如下;</strong> <strong> .text</strong> <strong>.global _start</strong> <strong>_start:</strong> <strong> LDR R0,=0x56000010 @GPBCON寄存器<br>MOV R1,# 0x00000400<br>STR R1,[R0]<br>LDR R0,=0x56000014<br>MOV R1,#0x00000000<br>STR R1,[R0]<br>MAIN_LOOP:<br>B MAIN_LOOP</strong> <strong>代码很简单，就是一个对io口 进行设置然后写数据。我们看它是如何编译的，注意我们这里使用的不是arm-linux-gcc而是arm-elf-gcc，二者之间没有什么比较大的区 别，arm-linux-gcc可能包含更多的库文件，在命令行的编译上面是没有区别。我们来看是如何编译的：</strong> <strong> arm-elf-gcc -g -c -o led_On.o led_On.s 首先纯编译不连接</strong> <strong> arm-elf-ld -Ttext 0x00000000 -g led_On.o -o led_on_elf</strong> <strong> 用Ttext指明我们程序存储的地方，这里生成的是elf文件，还不是我们真正的bin，但是可以借助一些工具可以进行调试。然后：</strong> <strong> arm-elf-objcopy -O binary -S led_on_elf led_on.bin </strong> <strong>生成bin文件。</strong> <strong>-T选项是ld命令中比较重要的一个选项，可以用它直接指明代码的代码段、数据段、bss段，对于复杂的连接，可以专门写一个脚本来告诉编译器如何连接。</strong> <strong> -Ttext&nbsp;&nbsp; addr</strong> <strong> -Tdata addr</strong> <strong> -Tbss&nbsp;&nbsp;&nbsp;&nbsp; addr</strong> <strong>arm-elf-ld -Ttext 0x00000000 -g led_On.o -o led_on_elf ，运行地址为0x00000000，由于没有指明数据段和bss，他们会默认的依次放在后面。相同的代码 不同的Ttext，你可以对比一下他们之间会变的差异，ld会自动调整跳转的地址。</strong> <strong>第二个概 念：section，section可以理解成一块，例如像c里面的一个子函数，就是一个section，链接器ld把object文件中的每个 section都作为一个整体，为其分配运行的地址(memory layout)，这个过程就是重定位(relocation)；最后把所有目标文件合并为一个目标文件。</strong> <strong>链接通过一个linker script来控制，这个脚本描述了输入文件的sections到输出文件的映射，以及输出文件的memory layout。</strong> <strong>因此，linker总会使用一个linker script，如果不特别指定，则使用默认的script；可以使用‘-T’命令行选项来指定一个linker script。</strong> <strong>＊映像文件的输入段与输出段</strong> <strong>linker把多个输入文件合并为一个输出文件。输出文件和输入文件都是目标文件(object file)，输出文件通常被称为可执行文件(executable)。</strong> <strong>每个目标文件都有一系列section，输入文件的section称为input section，输出文件的section则称为output section。</strong> <strong>一个section可以是 loadable的，即输出文件运行时需要将这样的section加载到memory(类似于RO&amp;RW段)；也可以是 allocatable的，这样的section没有任何内容，某些时候用0对相应的memory区域进行初始化(类似于ZI段)；如果一个 section既非loadable也非allocatable，则它通常包含的是调试信息。</strong> <strong>每个loadable或 allocatable的output section都有两个地址，一是VMA(virtual memory address)，是该section的运行时域地址；二是LMA(load memory address)，是该section的加载时域地址。</strong> <strong>可以通过objdump工具附加’-h’选项来查看目标文件中的sections。</strong> <strong>＊简单的Linker script</strong> <strong>(1) SECTIONS命令：</strong> <strong>The SECTIONS command tells the linker how to map input sections into output sections, and how to place the output sections in memory.</strong> <strong>命令格式如下：</strong> <strong>SECTIONS</strong> <strong>{</strong> <strong>sections-command</strong> <strong>sections-command</strong> <strong>……</strong> <strong>}</strong> <strong>其中sections-command可以是ENTRY命令，符号赋值，输出段描述，也可以是overlay描述。</strong> <strong>(2) 地址计数器‘.’(location counter)：</strong> <strong>该符号只能用于SECTIONS命令内部，初始值为‘0’，可以对该符号进行赋值，也可以使用该符号进行计算或赋值给其他符号。它会自动根据SECTIONS命令内部所描述的输出段的大小来计算当前的地址。</strong> <strong>(3) 输出段描述(output section description)：</strong> <strong>前面提到在SECTIONS命令中可以作输出段描述，描述的格式如下：</strong> <strong>section [address] [(type)] : [AT(lma)]</strong> <strong>{</strong> <strong>output-section-command</strong> <strong>output-section-command</strong> <strong>…</strong> <strong>} [&gt;region] [AT&gt;lma_region] [:phdr :phdr …] [=fillexp]</strong> <strong>很多附加选项是用不到的。其中的output-section-command又可以是符号赋值，输入段描述，要直接包含的数据值，或者某一特定的输出段关键字。</strong> <strong>＊linker script 实例</strong> <strong>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</strong> <strong>OUTPUT_ARCH(arm)</strong> <strong>ENTRY(_start)</strong> <strong>SECTIONS {</strong> <strong> . = 0xa3f00000;</strong> <strong> __boot_start = .;</strong> <strong> .start ALIGN(4) : {</strong> <strong> *(.text.start)</strong> <strong> }</strong> <strong> .setup ALIGN(4) : {</strong> <strong> setup_block = .;</strong> <strong> *(.setup)</strong> <strong> setup_block_end = .;</strong> <strong> }</strong> <strong> .text ALIGN(4) : {</strong> <strong> *(.text)</strong> <strong> }</strong> <strong> .rodata ALIGN(4) : {</strong> <strong> *(.rodata)</strong> <strong> }</strong> <strong> .data ALIGN(4) : {</strong> <strong> *(.data)</strong> <strong> }</strong> <strong> .got ALIGN(4) : {</strong> <strong> *(.got)</strong> <strong> }</strong> <strong> __boot_end = .;</strong> <strong> .bss ALIGN(16) : {</strong> <strong> bss_start = .;</strong> <strong> *(.bss)</strong> <strong> *(COMMON)</strong> <strong> bss_end = .;</strong> <strong> }</strong> <strong> .comment ALIGN(16) : {</strong> <strong> *(.comment)</strong> <strong> }</strong> <strong> stack_point = __boot_start + 0x00100000;</strong> <strong> loader_size = <strong>boot_end - </strong>boot_start;</strong> <strong> setup_size = setup_block_end - setup_block;</strong> <strong>}</strong> <strong>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ </strong> <strong>在SECTIONS命令中的类似于下面的描述结构就是输出段描述：</strong> <strong>.start ALIGN(4) : {</strong> <strong> *(.text.start)</strong> <strong>}</strong> <strong>.start 为output section name，ALIGN(4)返回一个基于location counter(.)的4字节对齐的地址值。<em>(.text.start)是输入段描述，</em>为通配符，意思是把所有被链接的object文件中 的.text.start段都链接进这个名为.start的输出段。</strong> <strong>源文件中所标识的section及其属性实际上就是对输入段的描述，例如.text.start输入段在源文件start.S中的代码如下：</strong> <strong>.section .text.start</strong> <strong>.global _start</strong> <strong>_start :</strong> <strong> b start</strong> <strong>arm-elf-ld -Ttimer.lds -o timer_elf header .o</strong> <strong>这里就必须存在一个timer.lds的文件。</strong> <strong>对于.lds文件，它定义了整个程序编译之后的连接过程，决定了一个可执行程序的各个段的存储位置。虽然现在我还没怎么用它，但感觉还是挺重要的，有必要了解一下。</strong> <strong>先看一下GNU官方网站上对.lds文件形式的完整描述：</strong> <strong>SECTIONS {<br>…<br>secname start BLOCK(align) (NOLOAD) : AT ( ldadr )<br>{ contents } &gt;region :phdr =fill<br>…<br>}</strong> <strong> </strong> <strong>secname和contents是必须的，其他的都是可选的。下面挑几个常用的看看：</strong> <strong>1、secname：段名</strong> <strong>2、contents：决定哪些内容放在本段，可以是整个目标文件，也可以是目标文件中的某段（代码段、数据段等）</strong> <strong>3、start：本段连接（运行）的地址，如果没有使用AT（ldadr），本段存储的地址也是start。GNU网站上说start可以用任意一种描述地址的符号来描述。</strong> <strong>4、AT（ldadr）：定义本段存储（加载）的地址。</strong> <strong>/<em> nand.lds </em>/<br>SECTIONS {<br>firtst 0x00000000 : { head.o init.o }<br>second 0x30000000 : AT(4096) { main.o }<br>}</strong> <strong> 以上，head.o放在0x00000000地址开始处，init.o放在head.o后面，他们的运行地址也是0x00000000，即连接和存储地址 相同（没有AT指定）；main.o放在4096（0x1000，是AT指定的，存储地址）开始处，但是它的运行地址在0x30000000，运行之前需 要从0x1000（加载处）复制到0x30000000（运行处），此过程也就用到了读取Nand flash。</strong> <strong>这就是存储地址和连接（运行）地址的不同，称为加载时域和运行时域，可以在.lds连接脚本文件中分别指定。</strong> <strong>编写好的.lds文件，在用arm-linux-ld连接命令时带-Tfilename来调用执行，如<br>arm-linux-ld –Tnand.lds x.o y.o –o xy.o。也用-Ttext参数直接指定连接地址，如<br>arm-linux-ld –Ttext 0x30000000 x.o y.o –o xy.o。</strong> <strong>既然程序有了两种地址，就涉及到一些跳转指令的区别，这里正好写下来，以后万一忘记了也可查看，以前不少东西没记下来现在忘得差不多了。</strong> <strong>ARM汇编中，常有两种跳转方法：b跳转指令、ldr指令向PC赋值。</strong> <strong>我自己经过归纳如下：</strong> <strong>b step1 ：b跳转指令是相对跳转，依赖当前PC的值，偏移量是通过该指令本身的bit[23:0]算出来的，这使得使用b指令的程序不依赖于要跳到的代码的位置，只看指令本身。</strong> <strong>ldr pc, =step1 ：该指令是从内存中的某个位置（step1）读出数据并赋给PC，同样依赖当前PC的值，但是偏移量是那个位置（step1）的连接地址（运行时的地址），所以可以用它实现从Flash到RAM的程序跳转。</strong> <strong>此外，有必要回味一下adr伪指令，U-boot中那段relocate代码就是通过adr实现当前程序是在RAM中还是flash中。仍然用我当时的注释</strong> <strong>adr r0, _start /<em> r0是代码的当前位置 </em>/<br>/<em> adr伪指令，汇编器自动通过当前PC的值算出 如果执行到_start时PC的值，放到r0中：<br>当 此段在flash中执行时r0 = _start = 0；当此段在RAM中执行时_start = _TEXT_BASE(在board/smdk2410/config.mk中指定的值为0x33F80000，即u-boot在把代码拷贝到RAM中去 执行的代码段的开始) </em>/</strong> <strong>ldr r1, _TEXT_BASE /<em> 测试判断是从Flash启动，还是RAM </em>/<br>/<em> 此句执行的结果r1始终是0x33FF80000，因为此值是又编译器指定的(ads中设置，或-D设置编译器参数) </em>/<br>cmp r0, r1 /<em> 比较r0和r1，调试的时候不要执行重定位 </em>/</strong> <strong> 下面，结合u-boot.lds看看一个正式的连接脚本文件。这个文件的基本功能还能看明白，虽然上面分析了好多，但其中那些GNU风格的符号还是着实让我感到迷惑。</strong> <strong>OUTPUT_FORMAT(“elf32&amp;shy;littlearm”, “elf32&amp;shy;littlearm”, “elf32&amp;shy;littlearm”)<br>;指定输出可执行文件是elf格式,32位ARM指令,小端<br>OUTPUT_ARCH(arm)<br>;指定输出可执行文件的平台为ARM<br>ENTRY(_start)<br>;指定输出可执行文件的起始代码段为_start.<br>SECTIONS<br>{<br>. = 0x00000000 ; 从0x0位置开始<br>. = ALIGN(4) ; 代码以4字节对齐<br>.text : ;指定代码段<br>{<br>cpu/arm920t/start.o (.text) ; 代码的第一个代码部分<br><em>(.text) ;其它代码部分<br>}<br>. = ALIGN(4)<br>.rodata : { </em>(.rodata) } ;指定只读数据段<br>. = ALIGN(4);<br>.data : { <em>(.data) } ;指定读/写数据段<br>. = ALIGN(4);<br>.got : { </em>(.got) } ;指定got段, got段式是uboot自定义的一个段, 非标准段<br><strong>u_boot_cmd_start = . ;把</strong>u_boot_cmd_start赋值为当前位置, 即起始位置<br>.u_boot_cmd : { <em>(.u_boot_cmd) } ;指定u_boot_cmd段, uboot把所有的uboot命令放在该段.<br><strong>u_boot_cmd_end = .;把</strong>u_boot_cmd_end赋值为当前位置,即结束位置<br>. = ALIGN(4);<br><strong>bss_start = .; 把</strong>bss_start赋值为当前位置,即bss段的开始位置<br>.bss : { </em>(.bss) }; 指定bss段<br>_end = .; 把_end赋值为当前位置,即bss段的结束位置<br>}</strong><br></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/25/e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac/" class="article-date">
  	<time datetime="2014-08-25T02:55:54.000Z" itemprop="datePublished">2014-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/25/e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac/">理解 Android Build 系统(转)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="dw-summary-area"><br><div><br><br>Android Build 系统是用来编译 Android 系统，Android SDK 以及相关文档的一套框架。众所周知，Android 是一个开源的操作系统。Android 的源码中包含了许许多多的模块。 不同产商的不同设备对于 Android 系统的定制都是不一样的。如何将这些模块统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型， 且还要提供面向各个产商的定制扩展，是非常有难度的。 但 Android Build 系统很好的解决了这些问题，这里面有很多值得我们开发人员学习的地方。对于 Android 平台开发人员来说，本文可以帮助你熟悉你每天接触到的构建环境。对于其他开发人员来说，本文可以作为一个 GNU Make 的使用案例，学习这些成功案例，可以提升我们的开发经验。<br><br>作者：<br><br></div><br><div><br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#authorN1001F" target="_blank" rel="external">强 波</a>, Java 软件工程师, 富士通南大软件技术有限公司<br><br>2013 年 3 月 28 日<br><br>原链接：<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/</a><br><br></div><br></div><br><div><br><div><br><br>## 前言<br><br>Android Build 系统是 Android 源码的一部分。关于如何获取 Android 源码，请参照 Android Source 官方网站：<br><br><a href="http://source.android.com/source/downloading.html" target="_blank" rel="external">http://source.android.com/source/downloading.html</a>。<br><br>Android Build 系统用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成，其中最主要的是 Make 文件。<br><br>众所周知，Android 是一个开源的操作系统。Android 的源码中包含了大量的开源项目以及许多的模块。不同产商的不同设备对于 Android 系统的定制都是不一样的。<br><br>如何将这些项目和模块的编译统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型，且还要提供面向各个产商的定制扩展，是非常有难度的。<br><br>但 Android Build 系统很好的解决了这些问题，这里面有很多值得我们开发人员学习的地方。<br><br>对于 Android 平台开发人员来说，本文可以帮助你熟悉你每天接触到的构建环境。<br><br>对于其他开发人员来说，本文可以作为一个 GNU Make 的使用案例，学习这些成功案例，可以提升我们的开发经验。<br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 概述<br><br>Build 系统中最主要的处理逻辑都在 Make 文件中，而其他的脚本文件只是起到一些辅助作用，由于篇幅所限，本文只探讨 Make 文件中的内容。<br><br>整个 Build 系统中的 Make 文件可以分为三类：<br><br>第一类是 Build 系统核心文件，此类文件定义了整个 Build 系统的框架，而其他所有 Make 文件都是在这个框架的基础上编写出来的。<br><br>图 1 是 Android 源码树的目录结构，Build 系统核心文件全部位于 /build/core（本文所提到的所有路径都是以 Android 源码树作为背景的，“/”指的是源码树的根目录，与文件系统无关）目录下。<br><br>##### 图 1. Android 源码树的目录结构<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image001.png" alt="图 1\. Android 源码树的目录结构">第 二类是针对某个产品（一个产品可能是某个型号的手机或者平板电脑）的 Make 文件，这些文件通常位于 device 目录下，该目录下又以公司名以及产品名分为两级目录，图 2 是 device 目录下子目录的结构。对于一个产品的定义通常需要一组文件，这些文件共同构成了对于这个产品的定义。例如，/device/sony/it26 目录下的文件共同构成了对于 Sony LT26 型号手机的定义。<br><br>##### 图 2. device 目录下子目录的结构<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image002.png" alt="图 2\. device 目录下子目录的结构">第 三类是针对某个模块（关于模块后文会详细讨论）的 Make 文件。整个系统中，包含了大量的模块，每个模块都有一个专门的 Make 文件，这类文件的名称统一为“Android.mk”，该文件中定义了如何编译当前模块。Build 系统会在整个源码树中扫描名称为“Android.mk”的文件并根据其中的内容执行模块的编译。<br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 编译 Android 系统<br><br>### 执行编译<br><br>Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="external">http://source.android.com/source/initializing.html</a><br><br>在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易：<br><br>打开控制台之后转到 Android 源码的根目录，然后执行如清单 1 所示的三条命令即可（<code>&quot;$&quot;</code>是命令提示符，不是命令的一部分。）：<br><br>完整的编译时间依赖于编译主机的配置，在笔者的 Macbook Pro（OS X 10.8.2, i7 2G CPU，8G RAM, 120G SSD）上使用 8 个 Job 同时编译共需要一个半小时左右的时间。<br><br>##### 清单 1. 编译 Android 系统<br><br><div><br><pre> $ source build/envsetup.sh<br> $ lunch full-eng<br> $ make -j8</pre><br></div><br>这三行命令的说明如下：<br><br>第一行命令“source build/envsetup.sh”引入了 <code>build/envsetup.sh</code>脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。<br><br>除此之外，该文件中还定义了其他一些常用的函数，它们如表 1 所示：<br><br>##### 表 1. build/envsetup.sh 中定义的常用函数<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>croot</strong></td><br><td>切换到源码树的根目录</td><br></tr><br><tr><br><td><strong>m</strong></td><br><td>在源码树的根目录执行 make</td><br></tr><br><tr><br><td><strong>mm</strong></td><br><td>Build 当前目录下的模块</td><br></tr><br><tr><br><td><strong>mmm</strong></td><br><td>Build 指定目录下的模块</td><br></tr><br><tr><br><td><strong>cgrep</strong></td><br><td>在所有 C/C++ 文件上执行 grep</td><br></tr><br><tr><br><td><strong>jgrep</strong></td><br><td>在所有 Java 文件上执行 grep</td><br></tr><br><tr><br><td><strong>resgrep</strong></td><br><td>在所有 res/<em>.xml 文件上执行 grep</em></td><br></tr><br><tr><br><td><strong>godir</strong></td><br><td>转到包含某个文件的目录路径</td><br></tr><br><tr><br><td><strong>printconfig</strong></td><br><td>显示当前 Build 的配置信息</td><br></tr><br><tr><br><td><strong>add_lunch_combo</strong></td><br><td>在 lunch 函数的菜单中添加一个条目</td><br></tr><br></tbody><br></table><br>第二行命令“lunch full-eng”是调用 lunch 函数，并指定参数为“full-eng”。lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。而编译类型会影响最终系统中包含的模块，关于编译类型将在表 7 中详细讲解。<br><br>如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，该列表类似图 3 中的内容（列表的内容会根据当前 Build 系统中包含的产品配置而不同，具体参见后文“添加新的产品”），此时可以通过输入编号或者名称进行选择。<br><br>##### 图 3. lunch 函数的输出<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image003.png" alt="图 3\. lunch 函数的输出">第三行命令“make -j8”才真正开始执行编译。make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。在调用 make 命令时，如果没有指定任何目标，则将使用默认的名称为“droid”目标，该目标会编译出完整的 Android 系统镜像。<br><br>### Build 结果的目录结构<br><br>所有的编译产物都将位于 /out 目录下，该目录下主要有以下几个子目录：

   /out/host/：该目录下包含了针对主机的 Android 开发工具的产物。即 SDK 中的各种工具，例如：emulator，adb，aapt 等。<br><em>   /out/target/common/：该目录下包含了针对设备的共通的编译产物，主要是 Java 应用代码和 Java 库。
</em>   /out/target/product/&lt;<em>product_name</em>&gt;/：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，<em>&lt;product_name&gt;</em>是具体目标设备的名称。<br><em>   /out/dist/：包含了为多种分发而准备的包，通过“<code>make dist</code><em>target</em>”将文件拷贝到该目录，默认的编译目标不会产生该目录。<br><br>### Build 生成的镜像文件<br><br>Build 的产物中最重要的是三个镜像文件，它们都位于 /out/target/product/&lt;<em>product_name</em>&gt;/ 目录下。<br><br>这三个文件是：

</em>   system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为根分区。<br><em>   ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。
</em>   userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。<br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## Make 文件说明<br><br>整个 Build 系统的入口文件是源码树根目录下名称为“Makefile”的文件，当在源代码根目录上调用 make 命令时，make 命令首先将读取该文件。<br><br>Makefile 文件的内容只有一行：“<code>include build/core/main.mk</code>”。该行代码的作用很明显：包含 build/core/main.mk 文件。在 main.mk 文件中又会包含其他的文件，其他文件中又会包含更多的文件，这样就引入了整个 Build 系统。<br><br>这些 Make 文件间的包含关系是相当复杂的，图 3 描述了这种关系，该图中黄色标记的文件（且除了 <code>$</code>开头的文件）都位于 build/core/ 目录下。<br><br>##### 图 4. 主要的 Make 文件及其包含关系<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image004.png" alt="图 4\. 主要的 Make 文件及其包含关系">表 2 总结了图 4 中提到的这些文件的作用：<br><br>##### 表 2. 主要的 Make 文件的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>文件名</th><br><th>说明</th><br></tr><br><tr><br><td><strong>main.mk</strong></td><br><td>最主要的 Make 文件，该文件中首先将对编译环境进行检查，同时引入其他的 Make 文件。另外，该文件中还定义了几个最主要的 Make 目标，例如 droid，sdk，等（参见后文“Make 目标说明”）。</td><br></tr><br><tr><br><td><strong>help.mk</strong></td><br><td>包含了名称为 help 的 Make 目标的定义，该目标将列出主要的 Make 目标及其说明。</td><br></tr><br><tr><br><td><strong>pathmap.mk</strong></td><br><td>将许多头文件的路径通过名值对的方式定义为映射表，并提供 include-path-for 函数来获取。例如，通过 <code>$(call include-path-for, frameworks-native)</code>便可以获取到 framework 本地代码需要的头文件路径。</td><br></tr><br><tr><br><td><strong>envsetup.mk</strong></td><br><td>配置 Build 系统需要的环境变量，例如：TARGET<em>PRODUCT，TARGET_BUILD_VARIANT，HOST_OS，HOST_ARCH 等。<br>当前编译的主机平台信息（例如操作系统，CPU 类型等信息）就是在这个文件中确定的。<br>另外，该文件中还指定了各种编译结果的输出路径。</em></td><br></tr><br><tr><br><td><strong>combo/select.mk</strong></td><br><td>根据当前编译器的平台选择平台相关的 Make 文件。</td><br></tr><br><tr><br><td><strong>dumpvar.mk</strong></td><br><td>在 Build 开始之前，显示此次 Build 的配置信息。</td><br></tr><br><tr><br><td><strong>config.mk</strong></td><br><td>整个 Build 系统的配置文件，最重要的 Make 文件之一。该文件中主要包含以下内容：<br><br><em>   定义了许多的常量来负责不同类型模块的编译。
</em>   定义编译器参数以及常见文件后缀，例如 .zip,.jar.apk。<br><em>   根据 BoardConfig.mk 文件，配置产品相关的参数。
</em>   设置一些常用工具的路径，例如 flex，e2fsck，dx。<br></td><br></tr><br><tr><br><td><strong>definitions.mk</strong></td><br><td>最重要的 Make 文件之一，在其中定义了大量的函数。这些函数都是 Build 系统的其他文件将用到的。例如：my-dir，all-subdir-makefiles，find-subdir-files，sign- package 等，关于这些函数的说明请参见每个函数的代码注释。</td><br></tr><br><tr><br><td><strong>distdir.mk</strong></td><br><td>针对 dist 目标的定义。dist 目标用来拷贝文件到指定路径。</td><br></tr><br><tr><br><td><strong>dex_preopt.mk</strong></td><br><td>针对启动 jar 包的预先优化。</td><br></tr><br><tr><br><td><strong>pdk_config.mk</strong></td><br><td>顾名思义，针对 pdk（Platform Developement Kit）的配置文件。</td><br></tr><br><tr><br><td><strong><code>${ONE_SHOT_MAKEFILE}</code></strong></td><br><td>ONE_SHOT_MAKEFILE 是一个变量，当使用“mm”编译某个目录下的模块时，此变量的值即为当前指定路径下的 Make 文件的路径。</td><br></tr><br><tr><br><td><strong><code>${subdir_makefiles}</code></strong></td><br><td>各个模块的 Android.mk 文件的集合，这个集合是通过 Python 脚本扫描得到的。</td><br></tr><br><tr><br><td><strong>post_clean.mk</strong></td><br><td>在前一次 Build 的基础上检查当前 Build 的配置，并执行必要清理工作。</td><br></tr><br><tr><br><td><strong>legacy_prebuilts.mk</strong></td><br><td>该文件中只定义了 GRANDFATHERED_ALL_PREBUILT 变量。</td><br></tr><br><tr><br><td><strong>Makefile</strong></td><br><td>被 main.mk 包含，该文件中的内容是辅助 main.mk 的一些额外内容。</td><br></tr><br></tbody><br></table><br>Android 源码中包含了许多的模块，模块的类型有很多种，例如：Java 库，C/C++ 库，APK 应用，以及可执行文件等 。并且，Java 或者 C/C++ 库还可以分为静态的或者动态的，库或可执行文件既可能是针对设备（本文的“设备”指的是 Android 系统将被安装的设备，例如某个型号的手机或平板）的也可能是针对主机（本文的“主机”指的是开发 Android 系统的机器，例如装有 Ubuntu 操作系统的 PC 机或装有 MacOS 的 iMac 或 Macbook）的。不同类型的模块的编译步骤和方法是不一样，为了能够一致且方便的执行各种类型模块的编译，在 config.mk 中定义了许多的常量，这其中的每个常量描述了一种类型模块的编译方式，这些常量有：<br><br><em>   BUILD_HOST_STATIC_LIBRARY
</em>   BUILD_HOST_SHARED_LIBRARY<br><em>   BUILD_STATIC_LIBRARY
</em>   BUILD_SHARED_LIBRARY<br><em>   BUILD_EXECUTABLE
</em>   BUILD_HOST_EXECUTABLE<br><em>   BUILD_PACKAGE
</em>   BUILD_PREBUILT<br><em>   BUILD_MULTI_PREBUILT
</em>   BUILD_HOST_PREBUILT<br><em>   BUILD_JAVA_LIBRARY
</em>   BUILD_STATIC_JAVA_LIBRARY<br>*   BUILD_HOST_JAVA_LIBRARY<br>通过名称大概就可以猜出每个变量所对应的模块类型。（在模块的 Android.mk 文件中，只要包含进这里对应的常量便可以执行相应类型模块的编译。对于 Android.mk 文件的编写请参见后文：“添加新的模块”。）<br><br>这 些常量的值都是另外一个 Make 文件的路径，详细的编译方式都是在对应的 Make 文件中定义的。这些常量和 Make 文件的是一一对应的，对应规则也很简单：常量的名称是 Make 文件的文件名除去后缀全部改为大写然后加上“BUILD”作为前缀。例如常量 BUILD<em>HOST_PREBUILT 的值对应的文件就是 host_prebuilt.mk。<br><br>这些 Make 文件的说明如表 3 所示：<br><br>##### 表 3. 各种模块的编译方式的定义文件<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>文件名</th><br><th>说明</th><br></tr><br><tr><br><td><strong>host_static_library.mk</strong></td><br><td>定义了如何编译主机上的静态库。</td><br></tr><br><tr><br><td><strong>host_shared_library.mk</strong></td><br><td>定义了如何编译主机上的共享库。</td><br></tr><br><tr><br><td><strong>static_library.mk</strong></td><br><td>定义了如何编译设备上的静态库。</td><br></tr><br><tr><br><td><strong>shared_library.mk</strong></td><br><td>定义了如何编译设备上的共享库。</td><br></tr><br><tr><br><td><strong>executable.mk</strong></td><br><td>定义了如何编译设备上的可执行文件。</td><br></tr><br><tr><br><td><strong>host_executable.mk</strong></td><br><td>定义了如何编译主机上的可执行文件。</td><br></tr><br><tr><br><td><strong>package.mk</strong></td><br><td>定义了如何编译 APK 文件。</td><br></tr><br><tr><br><td><strong>prebuilt.mk</strong></td><br><td>定义了如何处理一个已经编译好的文件 ( 例如 Jar 包 )。</td><br></tr><br><tr><br><td><strong>multi_prebuilt.mk</strong></td><br><td>定义了如何处理一个或多个已编译文件，该文件的实现依赖 prebuilt.mk。</td><br></tr><br><tr><br><td><strong>host_prebuilt.mk</strong></td><br><td>处理一个或多个主机上使用的已编译文件，该文件的实现依赖 multi_prebuilt.mk。</td><br></tr><br><tr><br><td><strong>java_library.mk</strong></td><br><td>定义了如何编译设备上的共享 Java 库。</td><br></tr><br><tr><br><td><strong>static_java_library.mk</strong></td><br><td>定义了如何编译设备上的静态 Java 库。</td><br></tr><br><tr><br><td><strong>host_java_library.mk</strong></td><br><td>定义了如何编译主机上的共享 Java 库。</td><br></tr><br></tbody><br></table><br>不同类型的模块的编译过程会有一些相同的步骤，例如：编译一个 Java 库和编译一个 APK 文件都需要定义如何编译 Java 文件。因此，表 3 中的这些 Make 文件的定义中会包含一些共同的代码逻辑。为了减少代码冗余，需要将共同的代码复用起来，复用的方式是将共同代码放到专门的文件中，然后在其他文件中包含这 些文件的方式来实现的。这些包含关系如图 5 所示。由于篇幅关系，这里就不再对其他文件做详细描述（其实这些文件从文件名称中就可以大致猜出其作用）。<br><br>##### 图 5. 模块的编译方式定义文件的包含关系<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image005.png" alt="图 5\. 模块的编译方式定义文件的包含关系"><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## Make 目标说明<br><br>### make /make droid<br><br>如果在源码树的根目录直接调用“make”命令而不指定任何目标，则会选择默认目标：“droid”（在 main.mk 中定义）。因此，这和执行“make droid”效果是一样的。<br><br>droid 目标将编译出整个系统的镜像。从源代码到编译出系统镜像，整个编译过程非常复杂。这个过程并不是在 droid 一个目标中定义的，而是 droid 目标会依赖许多其他的目标，这些目标的互相配合导致了整个系统的编译。<br><br>图 6 描述了 droid 目标所依赖的其他目标：<br><br>##### 图 6. droid 目标所依赖的其他 Make 目标<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image006.png" alt="图 6\. droid 目标所依赖的其他 Make 目标">图 6 中这些目标的说明如表 4 所示：<br><br>##### 表 4. droid 所依赖的其他 Make 目标的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>apps_only</strong></td><br><td>该目标将编译出当前配置下不包含 user，userdebug，eng 标签（关于标签，请参见后文“添加新的模块”）的应用程序。</td><br></tr><br><tr><br><td><strong>droidcore</strong></td><br><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td><br></tr><br><tr><br><td><strong>dist_files</strong></td><br><td>该目标用来拷贝文件到 /out/dist 目录。</td><br></tr><br><tr><br><td><strong>files</strong></td><br><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td><br></tr><br><tr><br><td><strong>prebuilt</strong></td><br><td>该目标依赖于 <code>$(ALL_PREBUILT)</code>，<code>$(ALL_PREBUILT)</code>的作用就是处理所有已编译好的文件。</td><br></tr><br><tr><br><td><strong><code>$(modules_to_install)</code></strong></td><br><td>modules_to_install 变量包含了当前配置下所有会被安装的模块（一个模块是否会被安装依赖于该产品的配置文件，模块的标签等信息），因此该目标将导致所有会被安装的模块的编译。</td><br></tr><br><tr><br><td><strong><code>$(modules_to_check)</code></strong></td><br><td>该目标用来确保我们定义的构建模块是没有冗余的。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_ANDROID_INFO_TXT_TARGET)</code></strong></td><br><td>该目标会生成一个关于当前 Build 配置的设备信息的文件，该文件的生成路径是：out/target/product/&lt;_product_name</td></tr></tbody></table></em>&gt;/android-info.txt<br><br><tr><br><td><strong>systemimage</strong></td><br><td>生成 system.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_BOOTIMAGE_TARGET)</code></strong></td><br><td>生成 boot.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_RECOVERYIMAGE_TARGET)</code></strong></td><br><td>生成 recovery.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_USERDATAIMAGE_TARGET)</code></strong></td><br><td>生成 userdata.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_CACHEIMAGE_TARGET)</code></strong></td><br><td>生成 cache.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_FILES_FILE)</code></strong></td><br><td>该目标会生成 out/target/product/&lt;<em>product_name</em>&gt;/ installed-files.txt 文件，该文件中内容是当前系统镜像中已经安装的文件列表。</td><br></tr><br><br><br><br>### 其他目标<br><br>Build 系统中包含的其他一些 Make 目标说明如表 5 所示：<br><br>##### 表 5. 其他主要 Make 目标<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>Make 目标</th><br><th>说明</th><br></tr><br><tr><br><td><strong>make clean</strong></td><br><td>执行清理，等同于：rm -rf out/。</td><br></tr><br><tr><br><td><strong>make sdk</strong></td><br><td>编译出 Android 的 SDK。</td><br></tr><br><tr><br><td><strong>make clean-sdk</strong></td><br><td>清理 SDK 的编译产物。</td><br></tr><br><tr><br><td><strong>make update-api</strong></td><br><td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的 API 记录在 frameworks/base/api 目录下。</td><br></tr><br><tr><br><td><strong>make dist</strong></td><br><td>执行 Build，并将 MAKECMDGOALS 变量定义的输出文件拷贝到 /out/dist 目录。</td><br></tr><br><tr><br><td><strong>make all</strong></td><br><td>编译所有内容，不管当前产品的定义中是否会包含。</td><br></tr><br><tr><br><td><strong>make help</strong></td><br><td>帮助信息，显示主要的 make 目标。</td><br></tr><br><tr><br><td><strong>make snod</strong></td><br><td>从已经编译出的包快速重建系统镜像。</td><br></tr><br><tr><br><td><strong>make libandroid_runtime</strong></td><br><td>编译所有 JNI framework 内容。</td><br></tr><br><tr><br><td><strong>make**</strong>framework<strong></strong></td><br><td>编译所有 Java framework 内容。</td><br></tr><br><tr><br><td>make<strong>**services</strong></td><br><td>编译系统服务和相关内容。</td><br></tr><br><tr><br><td><strong>make &lt;local_target&gt;</strong></td><br><td>编译一个指定的模块，local_target 为模块的名称。</td><br></tr><br><tr><br><td><strong>make clean-&lt;local_target&gt;</strong></td><br><td>清理一个指定模块的编译结果。</td><br></tr><br><tr><br><td><strong>make**</strong>dump-products<strong></strong></td><br><td>显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</td><br></tr><br><tr><br><td>make<strong>**PRODUCT-xxx-yyy</strong></td><br><td>编译某个指定的产品。</td><br></tr><br><tr><br><td><strong>make**</strong>bootimage<strong></strong></td><br><td>生成 boot.img</td><br></tr><br><tr><br><td>make<strong>**recoveryimage</strong></td><br><td>生成 recovery.img</td><br></tr><br><tr><br><td><strong>make**</strong>userdataimage<strong></strong></td><br><td>生成 userdata.img</td><br></tr><br><tr><br><td>make<strong>**cacheimage</strong></td><br><td>生成 cache.img</td><br></tr><br></tbody><br></table><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 在 Build 系统中添加新的内容<br><br>### 添加新的产品<br><br>当我们要开发一款新的 Android 产品的时候，我们首先就需要在 Build 系统中添加对于该产品的定义。<br><br>在 Android Build 系统中对产品定义的文件通常位于 device 目录下（另外还有一个可以定义产品的目录是 vender 目录，这是个历史遗留目录，Google 已经建议不要在该目录中进行定义，而应当选择 device 目录）。device 目录下根据公司名以及产品名分为二级目录，这一点我们在概述中已经提到过。<br><br>通常，对于一个产品的定义通常至少会包括四个文件：AndroidProducts.mk，产品版本定义文件，BoardConfig.mk 以及 verndorsetup.sh。下面我们来详细说明这几个文件。<br><br>*   AndroidProducts.mk：该文文件中的内容很简单，其中只需要定义一个变量，名称为“PRODUCT_MAKEFILES”，该变量的值为产品版本定义文件名的列表，例如：<br><div><br><pre> PRODUCT_MAKEFILES := \<br> $(LOCAL_DIR)/full_stingray.mk \<br> $(LOCAL_DIR)/stingray_emu.mk \<br> $(LOCAL_DIR)/generic_stingray.mk</pre><br></div>

<ul>
<li>产品版本定义文件：顾名思义，该文件中包含了对于特定产品版本的定义。该文件可能不只一个，因为同一个产品可能会有多种版本（例如，面向中国地区一个版本，面向美国地区一个版本）。该文件中可以定义的变量以及含义说明如表 6 所示：</li>
</ul>
<h5 id="表_6-_产品版本定义文件中的变量及其说明">表 6. 产品版本定义文件中的变量及其说明</h5><p><table summary="" border="0" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>常量</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_NAME</strong></td></p>
<p><td>最终用户将看到的完整产品名，会出现在“关于手机”信息中。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_MODEL</strong></td></p>
<p><td>产品的型号，这也是最终用户将看到的。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_LOCALES</strong></td></p>
<p><td>该产品支持的地区，以空格分格，例如：en_GB de_DE es_ES fr_CA。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PACKAGES</strong></td></p>
<p><td>该产品版本中包含的 APK 应用程序，以空格分格，例如：Calendar Contacts。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_DEVICE</strong></td></p>
<p><td>该产品的工业设计的名称。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_MANUFACTURER</strong></td></p>
<p><td>制造商的名称。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_BRAND</strong></td></p>
<p><td>该产品专门定义的商标（如果有的话）。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PROPERTY_OVERRIDES</strong></td></p>
<p><td>对于商品属性的定义。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_COPY_FILES</strong></td></p>
<p><td>编译该产品时需要拷贝的文件，以“源路径 : 目标路径”的形式。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_OTA_PUBLIC_KEYS</strong></td></p>
<p><td>对于该产品的 OTA 公开 key 的列表。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_POLICY</strong></td></p>
<p><td>产品使用的策略。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PACKAGE_OVERLAYS</strong></td></p>
<p><td>指出是否要使用默认的资源或添加产品特定定义来覆盖。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_CONTRIBUTORS_FILE</strong></td></p>
<p><td>HTML 文件，其中包含项目的贡献者。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_TAGS</strong></td></p>
<p><td>该产品的标签，以空格分格。</td><br><br><br><br>通常情况下，我们并不需要定义所有这些变量。Build 系统的已经预先定义好了一些组合，它们都位于 /build/target/product 下，每个文件定义了一个组合，我们只要继承这些预置的定义，然后再覆盖自己想要的变量定义即可。例如：</p>
<div><br><pre> # 继承 full_base.mk 文件中的定义<br> $(call inherit-product, $(SRC_TARGET_DIR)/product/full_base.mk)<br> # 覆盖其中已经定义的一些变量<br> PRODUCT_NAME := full_lt26<br> PRODUCT_DEVICE := lt26<br> PRODUCT_BRAND := Android<br> PRODUCT_MODEL := Full Android on LT26</pre><br></div>

<ul>
<li>BoardConfig.mk：该文件用来配置硬件主板，它其中定义的都是设备底层的硬件特性。例如：该设备的主板相关信息，Wifi 相关信息，还有 bootloader，内核，radioimage 等信息。对于该文件的示例，请参看 Android 源码树已经有的文件。</li>
<li>vendorsetup.sh：该文件中作用是通过 add_lunch_combo 函数在 lunch 函数中添加一个菜单选项。该函数的参数是产品名称加上编译类型，中间以“-”连接，例如：add_lunch_combo full_lt26-userdebug。/build/envsetup.sh 会扫描所有 device 和 vender 二 级目 录下的名称 为”vendorsetup.sh”文件，并根据其中的内容来确定 lunch 函数的 菜单选项。<br>在配置了以上的文件之后，便可以编译出我们新添加的设备的系统镜像了。</li>
</ul>
<p>首先，调用“<code>source build/envsetup.sh</code>”该命令的输出中会看到 Build 系统已经引入了刚刚添加的 vendorsetup.sh 文件。</p>
<p>然后再调用“lunch”函数，该函数输出的列表中将包含新添加的 vendorsetup.sh 中添加的条目。然后通过编号或名称选择即可。</p>
<p>最后，调用“make -j8”来执行编译即可。</p>
<h3 id="添加新的模块">添加新的模块</h3><p>关于“模块”的说明在上文中已经提到过，这里不再赘述。</p>
<p>在 源码树中，一个模块的所有文件通常都位于同一个文件夹中。为了将当前模块添加到整个 Build 系统中，每个模块都需要一个专门的 Make 文件，该文件的名称为“Android.mk”。Build 系统会扫描名称为“Android.mk”的文件，并根据该文件中内容编译出相应的产物。</p>
<p>需 要注意的是：在 Android Build 系统中，编译是以模块（而不是文件）作为单位的，每个模块都有一个唯一的名称，一个模块的依赖对象只能是另外一个模块，而不能是其他类型的对象。对于已经 编译好的二进制库，如果要用来被当作是依赖对象，那么应当将这些已经编译好的库作为单独的模块。对于这些已经编译好的库使用 BUILD_PREBUILT 或 BUILD_MULTI_PREBUILT。例如：当编译某个 Java 库需要依赖一些 Jar 包时，并不能直接指定 Jar 包的路径作为依赖，而必须首先将这些 Jar 包定义为一个模块，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。</p>
<p>下面，我们就来讲解 Android.mk 文件的编写：</p>
<p>Android.mk 文件通常以以下两行代码作为开头：</p>
<div><br><pre> LOCAL_PATH := $(call my-dir)<br> include $(CLEAR_VARS)</pre><br></div><br>这两行代码的作用是：<br><br>1.  设置当前模块的编译路径为当前文件夹路径。<br>2.  清理（可能由其他模块设置过的）编译环境中用到的变量。<br>为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括：<br><br><em>   LOCAL_SRC_FILES：当前模块包含的所有源代码文件。
</em>   LOCAL_MODULE：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。<br><em>   LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。
</em>   LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。<br><em>   LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。
</em>   LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。<br><em>   LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。
</em>   LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。<br><em>   LOCAL_PACKAGE_NAME：当前 APK 应用的名称。
</em>   LOCAL_CERTIFICATE：签署当前应用的证书名称。<br><em>   LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 debug, eng, user，development 或者 optional。其中，optional 是默认标签。标签是提供给编译类型使用的。不同的编译类型会安装包含不同标签的模块，关于编译类型的说明如表 7 所示：<br><br>##### 表 7. 编译类型的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>eng</strong></td><br><td>默认类型，该编译类型适用于开发阶段。<br>当选择这种类型时，编译结果将：

</td></tr></tbody></table></em>   安装包含 eng, debug, user，development 标签的模块<br><em>   安装所有没有标签的非 APK 模块
</em>   安装所有产品定义文件中指定的 APK 模块<br><br><br><tr><br><td><strong>user</strong></td><br><td>该编译类型适合用于最终发布阶段。<br>当选择这种类型时，编译结果将：<br><br><em>   安装所有带有 user 标签的模块
</em>   安装所有没有标签的非 APK 模块<br><em>   安装所有产品定义文件中指定的 APK 模块，APK 模块的标签将被忽略<br></em></td><br></tr><br><tr><br><td><strong>userdebug</strong></td><br><td>该编译类型适合用于 debug 阶段。<br>该类型和 user 一样，除了：

   会安装包含 debug 标签的模块<br><em>   编译出的系统具有 root 访问权限<br></em></td><br></tr><br><br><br>表 3 中的文件已经定义好了各种类型模块的编译方式。所以要执行编译，只需要引入表 3 中对应的 Make 文件即可（通过常量的方式）。例如，要编译一个 APK 文件，只需要在 Android.mk 文件中，加入“<code>include $(BUILD_PACKAGE)</code><br><br>除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括：

   <code>$(call my-dir)</code>：获取当前文件夹路径。<br><em>   <code>$(call all-java-files-under, &amp;lt;src&amp;gt;)</code>：获取指定目录下的所有 Java 文件。
</em>   <code>$(call all-c-files-under, &amp;lt;src&amp;gt;)</code>：获取指定目录下的所有 C 语言文件。<br><em>   <code>$(call all-Iaidl-files-under, &amp;lt;src&amp;gt;)</code> ：获取指定目录下的所有 AIDL 文件。
</em>   <code>$(call all-makefiles-under, &amp;lt;folder&amp;gt;)</code>：获取指定目录下的所有 Make 文件。<br>*   <code>$(call intermediates-dir-for, &amp;lt;class&amp;gt;, &amp;lt;app_name&amp;gt;, &amp;lt;host or target&amp;gt;, &amp;lt;common?&amp;gt; )</code>：获取 Build 输出的目标文件夹路径。<br>清单 2 和清单 3 分别是编译 APK 文件和编译 Java 静态库的 Make 文件示例：<br><br>##### 清单 2. 编译一个 APK 文件<br><br><div><br><pre>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)<br>  # 获取所有子目录中的 Java 文件<br>  LOCAL_SRC_FILES := $(call all-subdir-java-files)<br>  # 当前模块依赖的静态 Java 库，如果有多个以空格分隔<br>  LOCAL_STATIC_JAVA_LIBRARIES := static-library<br>  # 当前模块的名称<br>  LOCAL_PACKAGE_NAME := LocalPackage<br>  # 编译 APK 文件<br>  include $(BUILD_PACKAGE)</pre><br></div>

<h5 id="清单_3-_编译一个_Java_的静态库">清单 3. 编译一个 Java 的静态库</h5><div><br><pre>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)<br><br>  # 获取所有子目录中的 Java 文件<br>  LOCAL_SRC_FILES := $(call all-subdir-java-files)<br><br>  # 当前模块依赖的动态 Java 库名称<br>  LOCAL_JAVA_LIBRARIES := android.test.runner<br><br>  # 当前模块的名称<br>  LOCAL_MODULE := sample<br><br>  # 将当前模块编译成一个静态的 Java 库<br>  include $(BUILD_STATIC_JAVA_LIBRARY)</pre><br></div><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 结束语<br><br>整个 Build 系统包含了非常多的内容，由于篇幅所限，本文只能介绍其中最主要内容。<br><br>由于 Build 系统本身也是在随着 Android 平台不断的开发过程中，所以不同的版本其中的内容和定义可能会发生变化。网络上关于该部分的资料很零碎，并且很多资料中的一些内容已经过时不再适用，再加上缺少官方文档，所以该部分的学习存在一定的难度。<br><br>这就要求我们要有很强的代码阅读能力，毕竟代码是不会说谎的。 要知道，对于我们这些开发人员来说，源代码就是我们最忠实的朋友。 Use the Source,Luke!<br><br></div><br></div>

<h2 id="参考资料">参考资料</h2><h3 id="学习">学习</h3><ul>
<li><a href="http://source.android.com" target="_blank" rel="external">Android Open Source Project</a>：Android Source 官方网站。</li>
<li><a href="http://people.linaro.org/%7Easac/build-system.html" target="_blank" rel="external">Android Build System</a>：Build 系统中包含的说明文档。</li>
<li><a href="http://www.gnu.org/software/make/manual/html_node/index.html" target="_blank" rel="external">GNU `make’</a>：GNU make 官方手册。</li>
<li><a href="http://elinux.org/Android_Device" target="_blank" rel="external">Android Device</a>：大致介绍了 Build 系统中的一些文件。</li>
<li><a href="https://sites.google.com/a/itspaclub.com/www/android/android-build-system-anatomy" target="_blank" rel="external">Build System</a>：另一个关于 Build 系统的说明资料。</li>
<li><a href="http://www.android-x86.org/documents/how-to-add-new-x86-platforms" target="_blank" rel="external">Add new target</a>：该文档描述了如何添加一个新的产品目标。<br>&nbsp;</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/07/linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b/" class="article-date">
  	<time datetime="2014-08-07T08:26:52.000Z" itemprop="datePublished">2014-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/07/linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b/">linux 如何杀死僵尸进程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自blog.51osos.com/linux/linux-how-to-kill-zombie-process/<br>In UNIX System terminology, a process that has terminated,but whose parent has not yet waited for it, is called a zombie.<br>在UNIX 系统中,一个进程结束了,但是他的父进程没有等待(调用wait / waitpid)他, 那么他将变成一个僵尸进程. 在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用 waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵尸进程。<br>如何查看linux系统上的僵尸进程，如何统计有多少僵尸进程？</p>
<h1 id="ps_-ef_|_grep_defunct">ps -ef | grep defunct</h1><p>或者查找状态为Z的进程，Z就是代表zombie process,僵尸进程的意思。<br>另外使用top命令查看时有一栏为S,如果状态为Z说明它就是僵尸进程。<br>Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie<br>top命令中也统计了僵尸进程。或者使用下面的命令：<br>ps -ef | grep defunct | grep -v grep | wc -l<br>如何杀死僵尸进程呢？<br>一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。<br>ps -e -o ppid,stat | grep Z | cut -d” ” -f2 | xargs kill -9<br>或<br>kill -HUP <code>ps -A -ostat,ppid | grep -e ’^[Zz]‘ | awk ’{print $2}’</code><br>当然您可以自己编写更好的shell脚本，欢迎与大家分享。<br>另外子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。就是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，而此时，尽管对它的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。<br>如何避免僵尸进程呢？<br>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结 束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下 可以简单地将 SIGCHLD信号的操作设为SIG_IGN。<br>signal(SIGCHLD,SIG_IGN);<br>这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程<br>或者<br>用两次fork()，而且使紧跟的子进程直接退出，是的孙子进程成为孤儿进程，从而init进程将负责清除这个孤儿进程。<br>本文水平有限，关于zombie更深层次的理解欢迎在评论中与大家分享。<br>Tags: zombie<br>wmflw on 2013 年 9 月 25 日 at 下午 4:21 said:<br>ps -ef | grep defunct | grep -v grep | awk ‘{print “kill -9 “ $2,$3}’<br>一条自动命令，试了下还不错的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a><a class="article-category-link" href="/categories/杂七杂八/网摘/">网摘</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/29/e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop/" class="article-date">
  	<time datetime="2014-04-29T15:16:24.000Z" itemprop="datePublished">2014-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/29/e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop/">一起来玩hadoop</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""> </h1><pre><code>1 使用百度开放研究社区
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度提供了开放研究社区，这里我们可以用一个百度的hadoop资源，就不需要你自己搭建hadoop了，这多爽啊！下面我们来使用使用这个东西。</span><br></div>

<h2 id="-1"> </h2><h2 id="-2"> </h2><pre><code>1<span class="class">.2</span> 打开百度开放研究社区的<span class="tag">web</span> <span class="tag">Shell</span>
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度提供了一种类似shell的方式来提供交互。</span><br></div><br><div><br>    <span style="font-size:14px">我们在申请账号之后，进入到这个网页去看说明&nbsp;<a href="http://openresearch.baidu.com/activity/platform.jspx" target="_blank" rel="external">http://openresearch.baidu.com/activity/platform.jspx&nbsp;</a></span><br></div>

<h1 id="-3"> </h1><h1 id="-4"> </h1><pre><code>2 使用百度云平台
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度的这个云平台网址是<span style="font-family:times; orphans:0; text-indent:32px; widows:0"><a href="http://cc-ws.baidu.com" target="_blank" rel="external">http://cc-ws.baidu.com</a>，进入web shell之后如下图</span></span><br></div><br><div><br>    <span style="font-family:times; font-size:14px; orphans:0; text-indent:32px; widows:0"><img src="http://img.blog.csdn.net/20140429223342312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br></div><br><div><br>    <span style="font-family:times; orphans:0; text-indent:32px; widows:0"><span style="font-size:14px; white-space:pre"></span><span style="font-size:12px">图1 web shell</span></span><br></div><br><div><br>    <span style="font-family:times; orphans:0; text-indent:32px; widows:0"><span style="font-size:14px">这个可以认为是一个类unix的操作界面吧，不过这里只支持这些命令，下面主要讲讲用这个来进行一些hadoop的经典入门——wordCount</span></span><br></div>

<h2 id="-5"> </h2><pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-family:times; orphans:0; text-indent:32px; widows:0"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-size:14px"</span>&gt;</span>

<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><h2 id="-6"> </h2><pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-family:times; orphans:0; text-indent:32px; widows:0"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-size:14px"</span>&gt;</span>2.1 生成count所需的文件并且上传到百度的hadoop环境<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">由于这个百度自带的upload和download命令有点不好用，所以我用从自己的百度网盘里面搞数据过来，我在我的网盘里面上传了两个文件f1.txt,f2.txt</span><br></div><br><div><br>    <span style="font-size:14px"></span><br>    <pre lang="shell">hello world<span style="white-space:pre">    </span>#f1.txt</pre><br>    <div><br>        <span style="font-size:14px"><br><br>        </span><br>    </div><br>    <pre lang="shell">hello programmer<span style="white-space:pre">    </span>#f2.txt</pre><br><br>    然后通过命令把文件同步到hdfs上<br></div><br><div><br>    <span style="font-size:14px"></span><br>    &lt;pre lang=”shell””&gt;pan -put ./f*.txt ./input<br>    把网盘的两个文件都同步到hdfs目录下的input目录里面<br></div><br><div><br>    <span style="font-size:14px">然后使用</span><br></div><br><div><br>    <span style="font-size:14px"></span><br>    <pre lang="shell">hadoop fs -ls ./input</pre><br>    查看，结果如下<br></div><br><div><br>    <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429224934312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>    图2 结果已同步到hdfs上（涂掉的部分是我的用户名）<br><br>    </span><br><br>##<br>        <span style="font-size:14px"><br><br>        </span><br><br>##<br>        <span style="font-size:14px">2.2 使用自带的wordcount例子来运行wordcount</span><br><br>    <div><br>        <span style="font-size:14px"><br><br>        </span><br>    </div><br>    <div><br>        <span style="font-size:14px">百度的云平台有三个全局变量，hadoop命令如下介绍</span><br>    </div><br>    <div><br>        <span style="font-size:14px"></span><br>        <pre lang="shell">Hadoop命令<br>■ hadoop: 用于访问Hadoop的功能，其使用方式与命令行使用hadoop的方式一致。对于普通用户权限，其能够使用的hadoop命令包括hadoop fs，hadoop jar，hadoop job等。相对于hadoop命令的本地文件系统的当前路径即为用户的工作目录。为了访问hadoop系统的某些模块，平台也提供了三个变量可以直接使用，包括：$hadoop_home（hadoop系统的根目录）；$hadoop_examples（hadoop-examples-1.0.0.jar的路径），$hadoop_streaming（hadoop-streaming-1.0.0.jar的路径）</pre><br><br>        我们只需要执行下面的命令就可以统计了<br>    </div><br>    <div><br>        <span style="font-size:14px"></span><br>        <pre lang="shell">hadoop jar $hadoop_examples wordcount input output</pre><br>        运行结果如下<br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429225722859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        图三 这个是wordcount运行结果</span><br>    </div><br>    <div><br>        <span style="font-size:14px">我们进入output文件夹查看结果</span><br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429230101078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        </span><br>    </div><br>    <div><br>        <span style="font-size:14px">图四 这个是计算出来的结果，结果放在part-r-00000</span><br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429230337937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        </span><br>    </div><br>    <span style="font-size:14px">这下把这些单词统计过来了。</span><br></div><br><div><br>    <span style="font-size:14px">下次准备在本地写一个本地版本的wordcount，然后上传上来玩玩</span><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/28/e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6/" class="article-date">
  	<time datetime="2014-04-28T14:01:41.000Z" itemprop="datePublished">2014-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/28/e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6/">高可用MYSQL学习之路（一）——环境搭建&amp;mysql复制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""> </h1><pre><code>1.资源概述
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>由于实验室机器太少，手上只有一个服务器和自己的小笔记本，一直想玩玩这种感觉高大上的mysql集群，今天终于下定决心进行。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>在这里，我遇到了两个问题，先给大家阐述一下，希望能帮助大家</span><br></div><br><div><br><br><em>   <span style="font-size:18px;"><span style="white-space:pre">    </span>一台机器里面如何装多个mysql</span>
</em>   <span style="font-size:18px;"><span style="white-space:pre">    </span>为复制而创建的用户不能本地登录</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面围绕这两个问题进行解决。</span><br></div>

<h1 id="-1"> </h1><pre><code>2.如何在一台机器里面安装多个mysql
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>显然这个是开多个mysql的实例，只是对应着不同的端口就可以轻松达成。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面讲讲我的做法。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>1. 下载mysql源码，我这里下载的是mysql5.5.32的</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>2. 使用牛叉的cmake、make、make install进行安装</span><br></div><br><div><br>    <span style="white-space:pre">        </span><span style="font-size:24px;"><strong>安装第一个实例mysql1</strong></span><br></div><br><div><br>    <span style="white-space:pre">        </span>首先cmake<br></div><br><div><br>    <span style="white-space:pre">        </span><br>    <pre lang="shell">cmake \<br>-DCMAKE_INSTALL_PREFIX=/data/mysql1 \   #安装路径<br>-DMYSQL_DATADIR=/data/mysql1/data       \    #数据文件存放位置<br>-DSYSCONFDIR=/etc              \                                  #my.cnf路径<br>-DWITH_MYISAM_STORAGE_ENGINE=1    \       #支持MyIASM引擎<br>-DWITH_INNOBASE_STORAGE_ENGINE=1 \     #支持InnoDB引擎<br>-DWITH_MEMORY_STORAGE_ENGINE=1 \        #支持Memory引擎<br>-DWITH_READLINE=1                    \                         #快捷键功能(我没用过)<br>-DMYSQL_UNIX_ADDR=/data/mysql1/mysql1.sock      \   #连接数据库socket路径<br>-DMYSQL_TCP_PORT=3306                  \               #端口<br>-DENABLED_LOCAL_INFILE=1            \                #允许从本地导入数据<br>-DWITH_PARTITION_STORAGE_ENGINE=1  \   #安装支持数据库分区<br>-DEXTRA_CHARSETS=all                  \                   #安装所有的字符集<br>-DDEFAULT_CHARSET=utf8              \                   #默认字符<br>-DDEFAULT_COLLATION=utf8_general_ci</pre><br></div><br><div><br>    <span style="white-space:pre">        <span style="font-size:18px;">执行完毕之后我们然后make &amp; make install</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="white-space:pre">        </span><strong><span style="font-size:24px;">这样我们的mysql就安装好了。</span></strong></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style=" white-space: pre; "><strong>    </strong></span>然后我们需要做的事情就是为这个实例写一个配置文件</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">    </span>3. 为我们的这个实例搞一个配置文件</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">        </span>配置文件这个东西其实mysql都准备好了的，我们只需要拿出来改一改，进入到我们的安装目录/data/mysql1,将support-file文件夹下的my-medium.cnf作为我们的配置文件吧，</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space: pre; ">    </span>我将my-medium.cnf拷贝到了/data/mysql1目录下，并重命名为my.cnf，命令如下</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:14px;"><span style="white-space:pre">    </span></span></span><br>    <pre lang="shell">cp my-medium.cnf ../my.cnf</pre><br>    <span style="white-space:pre">    </span>打开我们的my.cnf，我们主要是需要改如下几个地方<br></div><br><div><br>    <span style="white-space:pre"></span><br>    <pre lang="shell">[client]<br>#password       = your_password<br><span style="font-size:24px;color:#999900;"><strong>port            = 3308<br>socket          = /data/mysql1/mysql1.sock</strong></span><span style="font-size:14px;"><br><br># Here follows entries for some specific programs<br><br># The MySQL server<br>[mysqld]<br></span><strong><span style="font-size:24px;color:#cc6600;">port            = 3308<br>socket          = /data/mysql1/mysql1.sock</span></strong><span style="font-size:14px;"><br>skip-external-locking<br>key_buffer_size = 16M<br>max_allowed_packet = 1M<br>table_open_cache = 64<br>sort_buffer_size = 512K<br>net_buffer_length = 8K<br>read_buffer_size = 256K<br>read_rnd_buffer_size = 512K<br>myisam_sort_buffer_size = 8M<br><br># Don’t listen on a TCP/IP port at all. This can be a security enhancement,<br># if all processes that need to connect to mysqld run on the same host.<br># All interaction with mysqld must be made via Unix sockets or named pipes.<br># Note that using this option without enabling named pipes on Windows<br># (via the &quot;enable-named-pipe&quot; option) will render mysqld useless!<br>#<br>#skip-networking<br><br># Replication Master Server (default)<br># binary logging is required for replication<br>log-bin=mysql1-bin<br><br># binary logging format - mixed recommended<br>binlog_format=mixed<br><br># required unique id between 1 and 2^32 - 1<br># defaults to 1 if master-host is not set<br># but will not function as a master if omitted<br></span><strong><span style="font-size:24px;background-color: rgb(255, 102, 0);">server-id       = 2</span></strong><span style="font-size:14px;"><br></span></pre><br><br>    <span style="font-size:18px;"><span style="white-space: pre; ">    </span>port不用说了，这个肯定是为每一个mysql确定一个端口，socket这个是指每个mysql实例需要用的sock文件，server-id这个是全局统一的id号，不可以出现重复的，这三个地方是需要注意的。</span><br></div><br><div><br>    <span style="white-space:pre"><span style="white-space:pre"><span style="font-size:18px;">    </span></span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">    </span>4. 配置文件更改完毕之后，我们对mysql这个实例进行初始化</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space: pre; ">    </span>进入到scripts文件夹下，运行下面的命令</span></span><br></div><br><div><br>    <span style="white-space:pre"></span><br>    <pre lang="shell">./mysql_install_db —defaults-file=/data/mysql1/my.cnf —basedir=/data/mysql1 —datadir=/data/mysql1/data —user=mysql</pre><br>    <span style="font-size:14px;"><br><br>    </span><span style="font-size:14px; white-space: pre; ">    </span><span style="font-size:18px;">—defaults-file是指我们刚刚修改的配置文件，</span><strong><span style="font-size:32px;color:#ff0000;">注意这里必须要用绝对路径，用相对路径就是个坑，坑爆了。</span></strong><br></div><br><div><br>    <span style="font-size: 14px; white-space: pre; ">    </span><span style="font-size:18px;">—basedir是指我们的这个实例所在的安装目录。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>—datadir是指我们这个实例以后放数据的文件夹</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space: pre; ">    </span>5.这个脚本执行成功之后，我们进入到其bin的文件夹下准备启动它</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>执行以下命令</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">./mysqld_safe —defaults-file=/data/mysql1/my.cnf<br></pre><br>    <span style="white-space:pre">    </span>一般的情况下，我们不出意外就可以启动它了<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>6.设置root的密码和远程访问的权限</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">./mysqladmin -P 3308 -S /data/mysql1/mysql1.sock -u root password</pre><br>    <span style="white-space:pre">    </span>由于我们是多个实例，所以我们需要随时指定-P端口 -S sock文件<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>为了方便，我自己写了两个小脚本进行处理，入参如下</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>第一个脚本runSQL.sh，主要是进行关闭和启动mysql的</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第一个参数是实例编号，像上面我们在/data/mysql1所以编号是1；</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第二个参数是命令，shutdown和start，分别控制启动和关闭</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第三个参数是端口号</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>以上三个参数都需要加上</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">dir=’/data/mysql’;<br>para=$1;<br>port=$3;<br>#echo $para;<br>sqlBasedir=$dir$para;<br>sqlDatadir=$sqlBasedir’/data’;<br>sqlRundir=$sqlBasedir’/bin’;<br>sqlConfigdir=$sqlBasedir’/my.cnf’;<br>sqlRunSock=$sqlBasedir’/mysql’$para’.sock’;<br>echo $2;<br>echo $sqlRundir;<br>cmd=&quot;start&quot;;<br>if [ &quot;$cmd&quot;x = &quot;$2&quot;x ];then<br>  echo ‘start’;<br>  $sqlRundir/mysqld_safe —defaults-file=$sqlConfigdir —user=mysql&amp;<br>  echo ‘ok’;<br>#echo $sqlBasedir;<br>#echo $sqlDatadir;<br>else<br>  echo ‘shutdown’;<br>  $sqlRundir/mysqladmin -P $port -S $sqlRunSock -uroot -p shutdown;<br>fi<br></pre><br><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre"><span style="white-space:pre">    </span>第二个</span>脚本是enterSQL.sh，主要是通过root账号进入到mysql控制台</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第一个参数是实例编号，意义同上一个脚本</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第二个参数是端口号</span><br></div><br><div><br>    <span style="font-size:18px;"></span><br>    <pre lang="shell">dir=’/data/mysql’;<br>para=$1;<br>port=$2;<br>#echo $para;<br>sqlBasedir=$dir$para;<br>sqlDatadir=$sqlBasedir’/data’;<br>sqlRundir=$sqlBasedir’/bin’;<br>sqlConfigdir=$sqlBasedir’/my.cnf’;<br>sqlRunSock=$sqlBasedir’/mysql’$para’.sock’;<br>$sqlRundir/mysql -P $port -S $sqlRunSock -uroot -p ;<br></pre><br><br>    <span style="white-space:pre">    </span>这下我们安装好了一个区别于一般情况的mysql实例了。<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面只需要重复上面的步骤，分别把上面my.cnf中的红色的地方换掉就可以了。</span><br></div>

<h1 id="-2"> </h1><pre><code>3.新建的用户不能本地登录
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>一开始我为主从复制创建了一个新的用户，<strong>结果我发现，新创建的用户是不能本地登录的！以至于我的slave总是连接不上master而不能进行复制操作。</strong></span><br></div><br><div><br>    <strong><span style="font-size:18px;"><span style="white-space:pre">    </span>参考下文</span></strong><br></div><br><div><br>    <span style="font-size:18px;"><span style="font-weight: bold; white-space: pre; ">    </span><a href="http://hi.baidu.com/dspace/item/11dd1b08a89710103a53eec4" target="_blank" rel="external">mysql新建用户无法登陆解决办法</a></span><br></div>

<h1 id="-3"> </h1><pre><code>4.来做我们的主从复制吧~
</code></pre><div><br>    <span style="font-size:18px;">·<span style="white-space:pre">    </span>在master上创建一个复制账号并且授权</span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;">    </span></span><br>    <pre lang="sql">create user repl_user;<br>grant replication slave on <em>.</em> to repl_user@’%’ identified by ‘123456’;</pre><br><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre"><span style="white-space:pre">    </span>然后</span>在slave上进行如下配置</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="sql">change master to master_host=’localhost’ master_port=3309 master_user=’repl_user’ master_password=’123456’</pre><br>    因为是在一台机器上所以host就是localhost，我选取的是一个端口为3309的mysql实例。<br></div><br><div><br>    <span style="font-size:18px;">执行完这句之后，然后执行</span><br></div><br><div><br>    <pre lang="sql"><span style="font-size:18px;">start slave</span></pre><br>    <span style="font-size:18px;"><br><br>    这样大功告成。</span><br></div><br><div><br>    <span style="font-size:18px;">有问题欢迎交流~</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span></span><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/MYSQL/">MYSQL</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e5-b0-be-e9-80-92-e5-bd-92" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/08/e5-b0-be-e9-80-92-e5-bd-92/" class="article-date">
  	<time datetime="2014-04-08T14:41:28.000Z" itemprop="datePublished">2014-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/08/e5-b0-be-e9-80-92-e5-bd-92/">尾递归</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.什么是递归？</p>
<pre><code>递归就是自己调用自己

2.编译器是如何实现递归的？

编译器是通过栈来实现递归，其实编译器也是通过栈来实现函数调用的，为了明白递归，我们先来看看我们的程序是如何实现函数调用的吧。

下面我们看一个函数调用的栗子
</code></pre><p><pre>int adder(int x,int y)<br>{<br> return x+y;<br>}</pre></p>
<p>void call()<br>{<br> int x=2;<br> int y=3;<br> adder(x,y);<br>}<br>&nbsp;</p>
<pre><code>我们使用gcc编译成汇编（PS：要想明白一个程序是怎么运行的最好的方式还是看汇编吧）
</code></pre><p><pre>gcc -S test.c</pre><br>&nbsp;</p>
<pre><code>下面我们看看汇编片段
</code></pre><p><pre><br>.file   “recu.c”<br>        .text<br>        .globl  adder<br>        .type   adder, @function<br>adder:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    %edi, -4(%rbp)<br>        movl    %esi, -8(%rbp)<br>        movl    -8(%rbp), %eax<br>        movl    -4(%rbp), %edx<br>        addl    %edx, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   adder, .-adder<br>        .globl  call<br>        .type   call, @function<br>call:<br>.LFB1:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    $2, -4(%rbp)<br>        movl    $3, -8(%rbp)<br>        movl    -8(%rbp), %edx<br>        movl    -4(%rbp), %eax<br>        movl    %edx, %esi<br>        movl    %eax, %edi<br>        call    adder<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE1:<br>        .size   call, .-call<br>        .ident  “GCC: (GNU) 4.8.2”<br>        .section        .note.GNU-stack,””,@progbits</pre><br>&nbsp;</p>
<pre><code>擦！汇编怎么那么多看不懂的符号啊？！！真拙计！

**我们这里是r开头的，原因是我们使用的是<span class="number">64</span>位的操作系统**

为了读懂汇编，我还是先去复习了一下，首先先明白几个寄存器吧

在X86上，用户寄存器为<span class="number">eax</span>, <span class="number">ebx</span>, <span class="number">ecx</span>, <span class="number">edx</span>, <span class="literal">esi</span>, <span class="literal">edi</span>, <span class="literal">ebp</span>, <span class="literal">esp</span> 以及<span class="literal">eip</span>
</code></pre><p>eax、ebx、ecx以及edx寄存器作为通用寄存器，可以用来进行临时存储</p>
<pre><code>esi和<span class="keyword">edi</span>可以用来存储，但对操作字符串类的函数有其他意义，在很多字符串操作指令中,&amp;nbsp;<span class="keyword">DS</span>:ESI指向源串,而ES:<span class="keyword">EDI</span>指向目标串
</code></pre><p>ebp通常用来容纳当前栈帧（stack frame）的内存地址，esp保存栈顶地址<br>eip保存当前执行指令的内存地址。机器代码不能直接修改该寄存器，只能通过jmp和call指令族进行间接修改，实现循环，调用等</p>
<p>&nbsp;</p>
<pre><code>然后我们在明白一下重要术语：

栈帧：值得是<span class="literal">ebp</span>到<span class="literal">esp</span>的这一段内存区间，每一个函数的调用都会生成一个栈帧，这里面保存着函数里的变量和指令。

我们主要关心<span class="keyword">call</span>函数以及adder函数，所以单独拿出来

我们先来看<span class="keyword">call</span>函数：
</code></pre><p><pre><em>**</em>这里的栈类别是指的向下满栈<br>call:<br>.LFB1:<br>        .cfi_startproc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##这个表示函数的入口参见<a href="http://web.mit.edu/wwinnie/MacData/afs/athena/project/rhel-doc/3/rhel-as-en-3/cfi-directives.html" target="_blank" rel="external">.cfi_startproc</a> pushq   %rbp   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp寄存器入栈<br>        .cfi_def_cfa_offset 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##定义CFI（call frame information）的cfa(<span style="font-family:Arial, sans-serif;font-size:14px;background-color:#eeeeee;">Canonical Frame Address</span>)的偏移量,主要是由于push了%rbp造成的偏移量<br>        .cfi_offset 6, -16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##.cfi我也不明<br>        movq    %rsp, %rbp             ##把rsp的值搞到rbp中去，表示现在进入了新栈<br>        .cfi_def_cfa_register 6        ##说明现在的cfa register是rbp<br>        subq    $16, %rsp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##空出两个单位，根据程序，我们应该猜得到是为x、y变量提供空间，为毛是压16个字节？难道是内存对其？<br>        movl    $2, -4(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp下面的一个4字节定义为x的空间<br>        movl    $3, -8(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp下面的第8个字节处定义成y的空间<br>        movl    -8(%rbp), %edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把x、y的地址赋给寄存器edx和eax，这两个是通用寄存器<br>        movl    -4(%rbp), %eax<br>        movl    %edx, %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##又把他们送个esi、edi这里是为传值做准备<br>        movl    %eax, %edi<br>        call    adder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ##这里调用adder函数，同时这个指令暗含一个把当前栈顶压入栈<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc</pre><br>下面用图来说明<br>&nbsp; <a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/03/绘图1.png" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/03/绘图1.png" alt="" title="frame"></a> &nbsp;<br>&nbsp;<br>好了，下面我们来谈谈尾递归。<br>主要围绕下面一个方面<br>1.什么是尾递归？与递归有什么区别？<br>我们先来一段代码来看看这两者之间的区别<br>&nbsp;</p>
<p><pre>int fact(int n){<br>      if(n &lt;0) return 0;<br>      if(n ==0) return 1;<br>      if(n ==1) return 1;<br>      return n*fact(n-1);<br>}</pre></p>
<p>int facttail(int n,int a){<br>      if(n &lt;0) return 0;<br>      if(n ==0) return 1;<br>      if(n ==1) return a;</p>
<pre><code><span class="keyword">return</span> facttail(<span class="keyword">n</span>-1,<span class="keyword">n</span>*a);
</code></pre><p>}<br>&nbsp;<br>fact函数是递归版本，facttail函数是尾递归版本。<br>&nbsp;<br>我们在文章最初知道了函数调用是通过栈帧来实现的，因为<strong><span style="font-size:16px;">栈帧中需要保存运算的变量</span></strong>，在使用递归的时候，比如函数fact，如果n非常大的话，很显然栈帧会越来越多，直到撑爆内存，这显然是我们不乐意见到的。<br>但是我们来看factail这个函数，它也是使用递归来实现求n的阶乘，但是注意到，这个函数中，<strong><span style="font-size:18px;">其栈帧是没有变量需要保存的</span></strong>，这就是说我们的栈帧是不需要的，我们完全可以就在原来的栈帧上进行运算！！<br>于是乎C编译器抖了个机灵，它如果发现了你使用了尾递归，他就会自动帮你优化，现在我们来看着两个函数的汇编。<br>为了看着方便，我们把判断全部删除，如下<br>&nbsp;</p>
<p><pre>int fact(int n){<br>      return n*fact(n-1);<br>}</pre></p>
<p>int facttail(int n,int a){<br>      return facttail(n-1,n*a);<br>}<br>汇编代码如下：<br>&nbsp;<br>&nbsp;</p>
<p><pre>fact:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    %edi, -4(%rbp)<br>        movl    -4(%rbp), %eax<br>        subl    $1, %eax<br>        movl    %eax, %edi<br>        call    fact<br>        imull   -4(%rbp), %eax<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   fact, .-fact<br>        .globl  facttail<br>        .type   facttail, @function<br>facttail:<br>.LFB1:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    %edi, -4(%rbp)<br>        movl    %esi, -8(%rbp)<br>        movl    -4(%rbp), %eax<br>        imull   -8(%rbp), %eax<br>        movl    -4(%rbp), %edx<br>        subl    $1, %edx<br>        movl    %eax, %esi<br>        movl    %edx, %edi<br>        call    facttail<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br></pre><br>卧槽！怎么都是递归呢？和传说中主动优化的不一样呢？<br>&nbsp;<br>原来是我搞忘记加入优化参数了，现在把优化参数加上，汇编代码如下<br>&nbsp;</p>
<p><pre>.file   “fact.c”<br>        .text<br>        .p2align 4,,15<br>        .globl  fact<br>        .type   fact, @function<br>fact:<br>.LFB7:<br>        .cfi_startproc<br>        .p2align 4,,10<br>        .p2align 3<br>.L2:<br>        jmp     .L2<br>        .cfi_endproc<br>.LFE7:<br>        .size   fact, .-fact<br>        .p2align 4,,15<br>        .globl  facttail<br>        .type   facttail, @function<br>facttail:<br>.LFB8:<br>        .cfi_startproc<br>        .p2align 4,,10<br>        .p2align 3<br>.L4:<br>        jmp     .L4<br>        .cfi_endproc<br>.LFE8:<br>        .size   facttail, .-facttail<br>        .ident  “GCC: (GNU) 4.8.2”<br>        .section        .note.GNU-stack,””,@progbits<br></pre><br>卧槽，我完全看不懂了，不过估计这东西优化成为了一个循环，看.L4，不过这个怎么把递归也搞成循环了？！这个真心不懂，求大家指教</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 培龙
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>