<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
<meta property="og:type" content="website">
<meta property="og:title" content="Long">
<meta property="og:url" content="http://royzhao.github.io/page/2/index.html">
<meta property="og:site_name" content="Long">
<meta property="og:description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Long">
<meta name="twitter:description" content="IF(I_FINISH_MY_WORK) { GOTO NEW_WORK; } ELSE { GOTO WORK_DAY_AND_NIGHT; }">
  
    <link rel="alternative" href="/atom.xml" title="Long" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">培龙</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/storage/" style="font-size: 10px;">-storage</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">骚年，你好</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">培龙</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">培龙</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/05/ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac/" class="article-date">
  	<time datetime="2014-09-05T06:23:36.000Z" itemprop="datePublished">2014-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/05/ld-e9-93-be-e6-8e-a5-e8-84-9a-e6-9c-ac-e8-bd-ac/">ld链接脚本(转)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""><div id="cnblogs_post_body"></div></h1><p>转自:<a href="http://www.cnblogs.com/Neddy/archive/2011/12/18/2291576.html" target="_blank" rel="external">http://www.cnblogs.com/Neddy/archive/2011/12/18/2291576.html</a><br>================================== <strong>我 们对每个c或者汇编文件进行单独编译，但是不去连接，生成很多.o 的文件，这些.o文件首先是分散的，我们首先要考虑的如何组合起来；其次，这些.o文件存在相互调用的关系；再者，我们最后生成的bin文件是要在硬件中 运行的，每一部分放在什么地址都要有仔细的说明。我觉得在写makefile的时候，最为重要的就是ld的理解，下面说说我的经验：</strong> <strong>首先，要确定我们的程序用没有用到标准的c库，或者一些系统的库文件，这些一般是在操作系统之上开发要注意的问题，这里并不多说，熟悉在Linux编程的人，基本上都会用ld命令；这里，我们从头开始,直接进行汇编语言的连接。</strong> <strong>我们写一个汇编程序，控制GPIO，从而控制外接的LED，代码如下;</strong> <strong> .text</strong> <strong>.global _start</strong> <strong>_start:</strong> <strong> LDR R0,=0x56000010 @GPBCON寄存器<br>MOV R1,# 0x00000400<br>STR R1,[R0]<br>LDR R0,=0x56000014<br>MOV R1,#0x00000000<br>STR R1,[R0]<br>MAIN_LOOP:<br>B MAIN_LOOP</strong> <strong>代码很简单，就是一个对io口 进行设置然后写数据。我们看它是如何编译的，注意我们这里使用的不是arm-linux-gcc而是arm-elf-gcc，二者之间没有什么比较大的区 别，arm-linux-gcc可能包含更多的库文件，在命令行的编译上面是没有区别。我们来看是如何编译的：</strong> <strong> arm-elf-gcc -g -c -o led_On.o led_On.s 首先纯编译不连接</strong> <strong> arm-elf-ld -Ttext 0x00000000 -g led_On.o -o led_on_elf</strong> <strong> 用Ttext指明我们程序存储的地方，这里生成的是elf文件，还不是我们真正的bin，但是可以借助一些工具可以进行调试。然后：</strong> <strong> arm-elf-objcopy -O binary -S led_on_elf led_on.bin </strong> <strong>生成bin文件。</strong> <strong>-T选项是ld命令中比较重要的一个选项，可以用它直接指明代码的代码段、数据段、bss段，对于复杂的连接，可以专门写一个脚本来告诉编译器如何连接。</strong> <strong> -Ttext&nbsp;&nbsp; addr</strong> <strong> -Tdata addr</strong> <strong> -Tbss&nbsp;&nbsp;&nbsp;&nbsp; addr</strong> <strong>arm-elf-ld -Ttext 0x00000000 -g led_On.o -o led_on_elf ，运行地址为0x00000000，由于没有指明数据段和bss，他们会默认的依次放在后面。相同的代码 不同的Ttext，你可以对比一下他们之间会变的差异，ld会自动调整跳转的地址。</strong> <strong>第二个概 念：section，section可以理解成一块，例如像c里面的一个子函数，就是一个section，链接器ld把object文件中的每个 section都作为一个整体，为其分配运行的地址(memory layout)，这个过程就是重定位(relocation)；最后把所有目标文件合并为一个目标文件。</strong> <strong>链接通过一个linker script来控制，这个脚本描述了输入文件的sections到输出文件的映射，以及输出文件的memory layout。</strong> <strong>因此，linker总会使用一个linker script，如果不特别指定，则使用默认的script；可以使用‘-T’命令行选项来指定一个linker script。</strong> <strong>＊映像文件的输入段与输出段</strong> <strong>linker把多个输入文件合并为一个输出文件。输出文件和输入文件都是目标文件(object file)，输出文件通常被称为可执行文件(executable)。</strong> <strong>每个目标文件都有一系列section，输入文件的section称为input section，输出文件的section则称为output section。</strong> <strong>一个section可以是 loadable的，即输出文件运行时需要将这样的section加载到memory(类似于RO&amp;RW段)；也可以是 allocatable的，这样的section没有任何内容，某些时候用0对相应的memory区域进行初始化(类似于ZI段)；如果一个 section既非loadable也非allocatable，则它通常包含的是调试信息。</strong> <strong>每个loadable或 allocatable的output section都有两个地址，一是VMA(virtual memory address)，是该section的运行时域地址；二是LMA(load memory address)，是该section的加载时域地址。</strong> <strong>可以通过objdump工具附加’-h’选项来查看目标文件中的sections。</strong> <strong>＊简单的Linker script</strong> <strong>(1) SECTIONS命令：</strong> <strong>The SECTIONS command tells the linker how to map input sections into output sections, and how to place the output sections in memory.</strong> <strong>命令格式如下：</strong> <strong>SECTIONS</strong> <strong>{</strong> <strong>sections-command</strong> <strong>sections-command</strong> <strong>……</strong> <strong>}</strong> <strong>其中sections-command可以是ENTRY命令，符号赋值，输出段描述，也可以是overlay描述。</strong> <strong>(2) 地址计数器‘.’(location counter)：</strong> <strong>该符号只能用于SECTIONS命令内部，初始值为‘0’，可以对该符号进行赋值，也可以使用该符号进行计算或赋值给其他符号。它会自动根据SECTIONS命令内部所描述的输出段的大小来计算当前的地址。</strong> <strong>(3) 输出段描述(output section description)：</strong> <strong>前面提到在SECTIONS命令中可以作输出段描述，描述的格式如下：</strong> <strong>section [address] [(type)] : [AT(lma)]</strong> <strong>{</strong> <strong>output-section-command</strong> <strong>output-section-command</strong> <strong>…</strong> <strong>} [&gt;region] [AT&gt;lma_region] [:phdr :phdr …] [=fillexp]</strong> <strong>很多附加选项是用不到的。其中的output-section-command又可以是符号赋值，输入段描述，要直接包含的数据值，或者某一特定的输出段关键字。</strong> <strong>＊linker script 实例</strong> <strong>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</strong> <strong>OUTPUT_ARCH(arm)</strong> <strong>ENTRY(_start)</strong> <strong>SECTIONS {</strong> <strong> . = 0xa3f00000;</strong> <strong> __boot_start = .;</strong> <strong> .start ALIGN(4) : {</strong> <strong> *(.text.start)</strong> <strong> }</strong> <strong> .setup ALIGN(4) : {</strong> <strong> setup_block = .;</strong> <strong> *(.setup)</strong> <strong> setup_block_end = .;</strong> <strong> }</strong> <strong> .text ALIGN(4) : {</strong> <strong> *(.text)</strong> <strong> }</strong> <strong> .rodata ALIGN(4) : {</strong> <strong> *(.rodata)</strong> <strong> }</strong> <strong> .data ALIGN(4) : {</strong> <strong> *(.data)</strong> <strong> }</strong> <strong> .got ALIGN(4) : {</strong> <strong> *(.got)</strong> <strong> }</strong> <strong> __boot_end = .;</strong> <strong> .bss ALIGN(16) : {</strong> <strong> bss_start = .;</strong> <strong> *(.bss)</strong> <strong> *(COMMON)</strong> <strong> bss_end = .;</strong> <strong> }</strong> <strong> .comment ALIGN(16) : {</strong> <strong> *(.comment)</strong> <strong> }</strong> <strong> stack_point = __boot_start + 0x00100000;</strong> <strong> loader_size = <strong>boot_end - </strong>boot_start;</strong> <strong> setup_size = setup_block_end - setup_block;</strong> <strong>}</strong> <strong>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ </strong> <strong>在SECTIONS命令中的类似于下面的描述结构就是输出段描述：</strong> <strong>.start ALIGN(4) : {</strong> <strong> *(.text.start)</strong> <strong>}</strong> <strong>.start 为output section name，ALIGN(4)返回一个基于location counter(.)的4字节对齐的地址值。<em>(.text.start)是输入段描述，</em>为通配符，意思是把所有被链接的object文件中 的.text.start段都链接进这个名为.start的输出段。</strong> <strong>源文件中所标识的section及其属性实际上就是对输入段的描述，例如.text.start输入段在源文件start.S中的代码如下：</strong> <strong>.section .text.start</strong> <strong>.global _start</strong> <strong>_start :</strong> <strong> b start</strong> <strong>arm-elf-ld -Ttimer.lds -o timer_elf header .o</strong> <strong>这里就必须存在一个timer.lds的文件。</strong> <strong>对于.lds文件，它定义了整个程序编译之后的连接过程，决定了一个可执行程序的各个段的存储位置。虽然现在我还没怎么用它，但感觉还是挺重要的，有必要了解一下。</strong> <strong>先看一下GNU官方网站上对.lds文件形式的完整描述：</strong> <strong>SECTIONS {<br>…<br>secname start BLOCK(align) (NOLOAD) : AT ( ldadr )<br>{ contents } &gt;region :phdr =fill<br>…<br>}</strong> <strong> </strong> <strong>secname和contents是必须的，其他的都是可选的。下面挑几个常用的看看：</strong> <strong>1、secname：段名</strong> <strong>2、contents：决定哪些内容放在本段，可以是整个目标文件，也可以是目标文件中的某段（代码段、数据段等）</strong> <strong>3、start：本段连接（运行）的地址，如果没有使用AT（ldadr），本段存储的地址也是start。GNU网站上说start可以用任意一种描述地址的符号来描述。</strong> <strong>4、AT（ldadr）：定义本段存储（加载）的地址。</strong> <strong>/<em> nand.lds </em>/<br>SECTIONS {<br>firtst 0x00000000 : { head.o init.o }<br>second 0x30000000 : AT(4096) { main.o }<br>}</strong> <strong> 以上，head.o放在0x00000000地址开始处，init.o放在head.o后面，他们的运行地址也是0x00000000，即连接和存储地址 相同（没有AT指定）；main.o放在4096（0x1000，是AT指定的，存储地址）开始处，但是它的运行地址在0x30000000，运行之前需 要从0x1000（加载处）复制到0x30000000（运行处），此过程也就用到了读取Nand flash。</strong> <strong>这就是存储地址和连接（运行）地址的不同，称为加载时域和运行时域，可以在.lds连接脚本文件中分别指定。</strong> <strong>编写好的.lds文件，在用arm-linux-ld连接命令时带-Tfilename来调用执行，如<br>arm-linux-ld –Tnand.lds x.o y.o –o xy.o。也用-Ttext参数直接指定连接地址，如<br>arm-linux-ld –Ttext 0x30000000 x.o y.o –o xy.o。</strong> <strong>既然程序有了两种地址，就涉及到一些跳转指令的区别，这里正好写下来，以后万一忘记了也可查看，以前不少东西没记下来现在忘得差不多了。</strong> <strong>ARM汇编中，常有两种跳转方法：b跳转指令、ldr指令向PC赋值。</strong> <strong>我自己经过归纳如下：</strong> <strong>b step1 ：b跳转指令是相对跳转，依赖当前PC的值，偏移量是通过该指令本身的bit[23:0]算出来的，这使得使用b指令的程序不依赖于要跳到的代码的位置，只看指令本身。</strong> <strong>ldr pc, =step1 ：该指令是从内存中的某个位置（step1）读出数据并赋给PC，同样依赖当前PC的值，但是偏移量是那个位置（step1）的连接地址（运行时的地址），所以可以用它实现从Flash到RAM的程序跳转。</strong> <strong>此外，有必要回味一下adr伪指令，U-boot中那段relocate代码就是通过adr实现当前程序是在RAM中还是flash中。仍然用我当时的注释</strong> <strong>adr r0, _start /<em> r0是代码的当前位置 </em>/<br>/<em> adr伪指令，汇编器自动通过当前PC的值算出 如果执行到_start时PC的值，放到r0中：<br>当 此段在flash中执行时r0 = _start = 0；当此段在RAM中执行时_start = _TEXT_BASE(在board/smdk2410/config.mk中指定的值为0x33F80000，即u-boot在把代码拷贝到RAM中去 执行的代码段的开始) </em>/</strong> <strong>ldr r1, _TEXT_BASE /<em> 测试判断是从Flash启动，还是RAM </em>/<br>/<em> 此句执行的结果r1始终是0x33FF80000，因为此值是又编译器指定的(ads中设置，或-D设置编译器参数) </em>/<br>cmp r0, r1 /<em> 比较r0和r1，调试的时候不要执行重定位 </em>/</strong> <strong> 下面，结合u-boot.lds看看一个正式的连接脚本文件。这个文件的基本功能还能看明白，虽然上面分析了好多，但其中那些GNU风格的符号还是着实让我感到迷惑。</strong> <strong>OUTPUT_FORMAT(“elf32&amp;shy;littlearm”, “elf32&amp;shy;littlearm”, “elf32&amp;shy;littlearm”)<br>;指定输出可执行文件是elf格式,32位ARM指令,小端<br>OUTPUT_ARCH(arm)<br>;指定输出可执行文件的平台为ARM<br>ENTRY(_start)<br>;指定输出可执行文件的起始代码段为_start.<br>SECTIONS<br>{<br>. = 0x00000000 ; 从0x0位置开始<br>. = ALIGN(4) ; 代码以4字节对齐<br>.text : ;指定代码段<br>{<br>cpu/arm920t/start.o (.text) ; 代码的第一个代码部分<br><em>(.text) ;其它代码部分<br>}<br>. = ALIGN(4)<br>.rodata : { </em>(.rodata) } ;指定只读数据段<br>. = ALIGN(4);<br>.data : { <em>(.data) } ;指定读/写数据段<br>. = ALIGN(4);<br>.got : { </em>(.got) } ;指定got段, got段式是uboot自定义的一个段, 非标准段<br><strong>u_boot_cmd_start = . ;把</strong>u_boot_cmd_start赋值为当前位置, 即起始位置<br>.u_boot_cmd : { <em>(.u_boot_cmd) } ;指定u_boot_cmd段, uboot把所有的uboot命令放在该段.<br><strong>u_boot_cmd_end = .;把</strong>u_boot_cmd_end赋值为当前位置,即结束位置<br>. = ALIGN(4);<br><strong>bss_start = .; 把</strong>bss_start赋值为当前位置,即bss段的开始位置<br>.bss : { </em>(.bss) }; 指定bss段<br>_end = .; 把_end赋值为当前位置,即bss段的结束位置<br>}</strong><br></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/25/e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac/" class="article-date">
  	<time datetime="2014-08-25T02:55:54.000Z" itemprop="datePublished">2014-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/25/e7-90-86-e8-a7-a3-android-build-e7-b3-bb-e7-bb-9f-e8-bd-ac/">理解 Android Build 系统(转)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div id="dw-summary-area"><br><div><br><br>Android Build 系统是用来编译 Android 系统，Android SDK 以及相关文档的一套框架。众所周知，Android 是一个开源的操作系统。Android 的源码中包含了许许多多的模块。 不同产商的不同设备对于 Android 系统的定制都是不一样的。如何将这些模块统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型， 且还要提供面向各个产商的定制扩展，是非常有难度的。 但 Android Build 系统很好的解决了这些问题，这里面有很多值得我们开发人员学习的地方。对于 Android 平台开发人员来说，本文可以帮助你熟悉你每天接触到的构建环境。对于其他开发人员来说，本文可以作为一个 GNU Make 的使用案例，学习这些成功案例，可以提升我们的开发经验。<br><br>作者：<br><br></div><br><div><br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#authorN1001F" target="_blank" rel="external">强 波</a>, Java 软件工程师, 富士通南大软件技术有限公司<br><br>2013 年 3 月 28 日<br><br>原链接：<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/</a><br><br></div><br></div><br><div><br><div><br><br>## 前言<br><br>Android Build 系统是 Android 源码的一部分。关于如何获取 Android 源码，请参照 Android Source 官方网站：<br><br><a href="http://source.android.com/source/downloading.html" target="_blank" rel="external">http://source.android.com/source/downloading.html</a>。<br><br>Android Build 系统用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成，其中最主要的是 Make 文件。<br><br>众所周知，Android 是一个开源的操作系统。Android 的源码中包含了大量的开源项目以及许多的模块。不同产商的不同设备对于 Android 系统的定制都是不一样的。<br><br>如何将这些项目和模块的编译统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型，且还要提供面向各个产商的定制扩展，是非常有难度的。<br><br>但 Android Build 系统很好的解决了这些问题，这里面有很多值得我们开发人员学习的地方。<br><br>对于 Android 平台开发人员来说，本文可以帮助你熟悉你每天接触到的构建环境。<br><br>对于其他开发人员来说，本文可以作为一个 GNU Make 的使用案例，学习这些成功案例，可以提升我们的开发经验。<br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 概述<br><br>Build 系统中最主要的处理逻辑都在 Make 文件中，而其他的脚本文件只是起到一些辅助作用，由于篇幅所限，本文只探讨 Make 文件中的内容。<br><br>整个 Build 系统中的 Make 文件可以分为三类：<br><br>第一类是 Build 系统核心文件，此类文件定义了整个 Build 系统的框架，而其他所有 Make 文件都是在这个框架的基础上编写出来的。<br><br>图 1 是 Android 源码树的目录结构，Build 系统核心文件全部位于 /build/core（本文所提到的所有路径都是以 Android 源码树作为背景的，“/”指的是源码树的根目录，与文件系统无关）目录下。<br><br>##### 图 1. Android 源码树的目录结构<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image001.png" alt="图 1\. Android 源码树的目录结构">第 二类是针对某个产品（一个产品可能是某个型号的手机或者平板电脑）的 Make 文件，这些文件通常位于 device 目录下，该目录下又以公司名以及产品名分为两级目录，图 2 是 device 目录下子目录的结构。对于一个产品的定义通常需要一组文件，这些文件共同构成了对于这个产品的定义。例如，/device/sony/it26 目录下的文件共同构成了对于 Sony LT26 型号手机的定义。<br><br>##### 图 2. device 目录下子目录的结构<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image002.png" alt="图 2\. device 目录下子目录的结构">第 三类是针对某个模块（关于模块后文会详细讨论）的 Make 文件。整个系统中，包含了大量的模块，每个模块都有一个专门的 Make 文件，这类文件的名称统一为“Android.mk”，该文件中定义了如何编译当前模块。Build 系统会在整个源码树中扫描名称为“Android.mk”的文件并根据其中的内容执行模块的编译。<br><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 编译 Android 系统<br><br>### 执行编译<br><br>Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。关于编译环境的构建方法请参见以下路径：<a href="http://source.android.com/source/initializing.html" target="_blank" rel="external">http://source.android.com/source/initializing.html</a><br><br>在完成编译环境的准备工作以及获取到完整的 Android 源码之后，想要编译出整个 Android 系统非常的容易：<br><br>打开控制台之后转到 Android 源码的根目录，然后执行如清单 1 所示的三条命令即可（<code>&quot;$&quot;</code>是命令提示符，不是命令的一部分。）：<br><br>完整的编译时间依赖于编译主机的配置，在笔者的 Macbook Pro（OS X 10.8.2, i7 2G CPU，8G RAM, 120G SSD）上使用 8 个 Job 同时编译共需要一个半小时左右的时间。<br><br>##### 清单 1. 编译 Android 系统<br><br><div><br><pre> $ source build/envsetup.sh<br> $ lunch full-eng<br> $ make -j8</pre><br></div><br>这三行命令的说明如下：<br><br>第一行命令“source build/envsetup.sh”引入了 <code>build/envsetup.sh</code>脚本。该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数，这其中就包括第二步使用 lunch 函数。<br><br>除此之外，该文件中还定义了其他一些常用的函数，它们如表 1 所示：<br><br>##### 表 1. build/envsetup.sh 中定义的常用函数<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>croot</strong></td><br><td>切换到源码树的根目录</td><br></tr><br><tr><br><td><strong>m</strong></td><br><td>在源码树的根目录执行 make</td><br></tr><br><tr><br><td><strong>mm</strong></td><br><td>Build 当前目录下的模块</td><br></tr><br><tr><br><td><strong>mmm</strong></td><br><td>Build 指定目录下的模块</td><br></tr><br><tr><br><td><strong>cgrep</strong></td><br><td>在所有 C/C++ 文件上执行 grep</td><br></tr><br><tr><br><td><strong>jgrep</strong></td><br><td>在所有 Java 文件上执行 grep</td><br></tr><br><tr><br><td><strong>resgrep</strong></td><br><td>在所有 res/<em>.xml 文件上执行 grep</em></td><br></tr><br><tr><br><td><strong>godir</strong></td><br><td>转到包含某个文件的目录路径</td><br></tr><br><tr><br><td><strong>printconfig</strong></td><br><td>显示当前 Build 的配置信息</td><br></tr><br><tr><br><td><strong>add_lunch_combo</strong></td><br><td>在 lunch 函数的菜单中添加一个条目</td><br></tr><br></tbody><br></table><br>第二行命令“lunch full-eng”是调用 lunch 函数，并指定参数为“full-eng”。lunch 函数的参数用来指定此次编译的目标设备以及编译类型。在这里，这两个值分别是“full”和“eng”。“full”是 Android 源码中已经定义好的一种产品，是为模拟器而设置的。而编译类型会影响最终系统中包含的模块，关于编译类型将在表 7 中详细讲解。<br><br>如果调用 lunch 函数的时候没有指定参数，那么该函数将输出列表以供选择，该列表类似图 3 中的内容（列表的内容会根据当前 Build 系统中包含的产品配置而不同，具体参见后文“添加新的产品”），此时可以通过输入编号或者名称进行选择。<br><br>##### 图 3. lunch 函数的输出<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image003.png" alt="图 3\. lunch 函数的输出">第三行命令“make -j8”才真正开始执行编译。make 的参数“-j”指定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍（例如：在一个 4 核，每个核支持两个线程的 CPU 上，可以使用 make -j8 或 make -j16）。在调用 make 命令时，如果没有指定任何目标，则将使用默认的名称为“droid”目标，该目标会编译出完整的 Android 系统镜像。<br><br>### Build 结果的目录结构<br><br>所有的编译产物都将位于 /out 目录下，该目录下主要有以下几个子目录：

   /out/host/：该目录下包含了针对主机的 Android 开发工具的产物。即 SDK 中的各种工具，例如：emulator，adb，aapt 等。<br><em>   /out/target/common/：该目录下包含了针对设备的共通的编译产物，主要是 Java 应用代码和 Java 库。
</em>   /out/target/product/&lt;<em>product_name</em>&gt;/：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，<em>&lt;product_name&gt;</em>是具体目标设备的名称。<br><em>   /out/dist/：包含了为多种分发而准备的包，通过“<code>make dist</code><em>target</em>”将文件拷贝到该目录，默认的编译目标不会产生该目录。<br><br>### Build 生成的镜像文件<br><br>Build 的产物中最重要的是三个镜像文件，它们都位于 /out/target/product/&lt;<em>product_name</em>&gt;/ 目录下。<br><br>这三个文件是：

</em>   system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为根分区。<br><em>   ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。
</em>   userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。<br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## Make 文件说明<br><br>整个 Build 系统的入口文件是源码树根目录下名称为“Makefile”的文件，当在源代码根目录上调用 make 命令时，make 命令首先将读取该文件。<br><br>Makefile 文件的内容只有一行：“<code>include build/core/main.mk</code>”。该行代码的作用很明显：包含 build/core/main.mk 文件。在 main.mk 文件中又会包含其他的文件，其他文件中又会包含更多的文件，这样就引入了整个 Build 系统。<br><br>这些 Make 文件间的包含关系是相当复杂的，图 3 描述了这种关系，该图中黄色标记的文件（且除了 <code>$</code>开头的文件）都位于 build/core/ 目录下。<br><br>##### 图 4. 主要的 Make 文件及其包含关系<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image004.png" alt="图 4\. 主要的 Make 文件及其包含关系">表 2 总结了图 4 中提到的这些文件的作用：<br><br>##### 表 2. 主要的 Make 文件的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>文件名</th><br><th>说明</th><br></tr><br><tr><br><td><strong>main.mk</strong></td><br><td>最主要的 Make 文件，该文件中首先将对编译环境进行检查，同时引入其他的 Make 文件。另外，该文件中还定义了几个最主要的 Make 目标，例如 droid，sdk，等（参见后文“Make 目标说明”）。</td><br></tr><br><tr><br><td><strong>help.mk</strong></td><br><td>包含了名称为 help 的 Make 目标的定义，该目标将列出主要的 Make 目标及其说明。</td><br></tr><br><tr><br><td><strong>pathmap.mk</strong></td><br><td>将许多头文件的路径通过名值对的方式定义为映射表，并提供 include-path-for 函数来获取。例如，通过 <code>$(call include-path-for, frameworks-native)</code>便可以获取到 framework 本地代码需要的头文件路径。</td><br></tr><br><tr><br><td><strong>envsetup.mk</strong></td><br><td>配置 Build 系统需要的环境变量，例如：TARGET<em>PRODUCT，TARGET_BUILD_VARIANT，HOST_OS，HOST_ARCH 等。<br>当前编译的主机平台信息（例如操作系统，CPU 类型等信息）就是在这个文件中确定的。<br>另外，该文件中还指定了各种编译结果的输出路径。</em></td><br></tr><br><tr><br><td><strong>combo/select.mk</strong></td><br><td>根据当前编译器的平台选择平台相关的 Make 文件。</td><br></tr><br><tr><br><td><strong>dumpvar.mk</strong></td><br><td>在 Build 开始之前，显示此次 Build 的配置信息。</td><br></tr><br><tr><br><td><strong>config.mk</strong></td><br><td>整个 Build 系统的配置文件，最重要的 Make 文件之一。该文件中主要包含以下内容：<br><br><em>   定义了许多的常量来负责不同类型模块的编译。
</em>   定义编译器参数以及常见文件后缀，例如 .zip,.jar.apk。<br><em>   根据 BoardConfig.mk 文件，配置产品相关的参数。
</em>   设置一些常用工具的路径，例如 flex，e2fsck，dx。<br></td><br></tr><br><tr><br><td><strong>definitions.mk</strong></td><br><td>最重要的 Make 文件之一，在其中定义了大量的函数。这些函数都是 Build 系统的其他文件将用到的。例如：my-dir，all-subdir-makefiles，find-subdir-files，sign- package 等，关于这些函数的说明请参见每个函数的代码注释。</td><br></tr><br><tr><br><td><strong>distdir.mk</strong></td><br><td>针对 dist 目标的定义。dist 目标用来拷贝文件到指定路径。</td><br></tr><br><tr><br><td><strong>dex_preopt.mk</strong></td><br><td>针对启动 jar 包的预先优化。</td><br></tr><br><tr><br><td><strong>pdk_config.mk</strong></td><br><td>顾名思义，针对 pdk（Platform Developement Kit）的配置文件。</td><br></tr><br><tr><br><td><strong><code>${ONE_SHOT_MAKEFILE}</code></strong></td><br><td>ONE_SHOT_MAKEFILE 是一个变量，当使用“mm”编译某个目录下的模块时，此变量的值即为当前指定路径下的 Make 文件的路径。</td><br></tr><br><tr><br><td><strong><code>${subdir_makefiles}</code></strong></td><br><td>各个模块的 Android.mk 文件的集合，这个集合是通过 Python 脚本扫描得到的。</td><br></tr><br><tr><br><td><strong>post_clean.mk</strong></td><br><td>在前一次 Build 的基础上检查当前 Build 的配置，并执行必要清理工作。</td><br></tr><br><tr><br><td><strong>legacy_prebuilts.mk</strong></td><br><td>该文件中只定义了 GRANDFATHERED_ALL_PREBUILT 变量。</td><br></tr><br><tr><br><td><strong>Makefile</strong></td><br><td>被 main.mk 包含，该文件中的内容是辅助 main.mk 的一些额外内容。</td><br></tr><br></tbody><br></table><br>Android 源码中包含了许多的模块，模块的类型有很多种，例如：Java 库，C/C++ 库，APK 应用，以及可执行文件等 。并且，Java 或者 C/C++ 库还可以分为静态的或者动态的，库或可执行文件既可能是针对设备（本文的“设备”指的是 Android 系统将被安装的设备，例如某个型号的手机或平板）的也可能是针对主机（本文的“主机”指的是开发 Android 系统的机器，例如装有 Ubuntu 操作系统的 PC 机或装有 MacOS 的 iMac 或 Macbook）的。不同类型的模块的编译步骤和方法是不一样，为了能够一致且方便的执行各种类型模块的编译，在 config.mk 中定义了许多的常量，这其中的每个常量描述了一种类型模块的编译方式，这些常量有：<br><br><em>   BUILD_HOST_STATIC_LIBRARY
</em>   BUILD_HOST_SHARED_LIBRARY<br><em>   BUILD_STATIC_LIBRARY
</em>   BUILD_SHARED_LIBRARY<br><em>   BUILD_EXECUTABLE
</em>   BUILD_HOST_EXECUTABLE<br><em>   BUILD_PACKAGE
</em>   BUILD_PREBUILT<br><em>   BUILD_MULTI_PREBUILT
</em>   BUILD_HOST_PREBUILT<br><em>   BUILD_JAVA_LIBRARY
</em>   BUILD_STATIC_JAVA_LIBRARY<br>*   BUILD_HOST_JAVA_LIBRARY<br>通过名称大概就可以猜出每个变量所对应的模块类型。（在模块的 Android.mk 文件中，只要包含进这里对应的常量便可以执行相应类型模块的编译。对于 Android.mk 文件的编写请参见后文：“添加新的模块”。）<br><br>这 些常量的值都是另外一个 Make 文件的路径，详细的编译方式都是在对应的 Make 文件中定义的。这些常量和 Make 文件的是一一对应的，对应规则也很简单：常量的名称是 Make 文件的文件名除去后缀全部改为大写然后加上“BUILD”作为前缀。例如常量 BUILD<em>HOST_PREBUILT 的值对应的文件就是 host_prebuilt.mk。<br><br>这些 Make 文件的说明如表 3 所示：<br><br>##### 表 3. 各种模块的编译方式的定义文件<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>文件名</th><br><th>说明</th><br></tr><br><tr><br><td><strong>host_static_library.mk</strong></td><br><td>定义了如何编译主机上的静态库。</td><br></tr><br><tr><br><td><strong>host_shared_library.mk</strong></td><br><td>定义了如何编译主机上的共享库。</td><br></tr><br><tr><br><td><strong>static_library.mk</strong></td><br><td>定义了如何编译设备上的静态库。</td><br></tr><br><tr><br><td><strong>shared_library.mk</strong></td><br><td>定义了如何编译设备上的共享库。</td><br></tr><br><tr><br><td><strong>executable.mk</strong></td><br><td>定义了如何编译设备上的可执行文件。</td><br></tr><br><tr><br><td><strong>host_executable.mk</strong></td><br><td>定义了如何编译主机上的可执行文件。</td><br></tr><br><tr><br><td><strong>package.mk</strong></td><br><td>定义了如何编译 APK 文件。</td><br></tr><br><tr><br><td><strong>prebuilt.mk</strong></td><br><td>定义了如何处理一个已经编译好的文件 ( 例如 Jar 包 )。</td><br></tr><br><tr><br><td><strong>multi_prebuilt.mk</strong></td><br><td>定义了如何处理一个或多个已编译文件，该文件的实现依赖 prebuilt.mk。</td><br></tr><br><tr><br><td><strong>host_prebuilt.mk</strong></td><br><td>处理一个或多个主机上使用的已编译文件，该文件的实现依赖 multi_prebuilt.mk。</td><br></tr><br><tr><br><td><strong>java_library.mk</strong></td><br><td>定义了如何编译设备上的共享 Java 库。</td><br></tr><br><tr><br><td><strong>static_java_library.mk</strong></td><br><td>定义了如何编译设备上的静态 Java 库。</td><br></tr><br><tr><br><td><strong>host_java_library.mk</strong></td><br><td>定义了如何编译主机上的共享 Java 库。</td><br></tr><br></tbody><br></table><br>不同类型的模块的编译过程会有一些相同的步骤，例如：编译一个 Java 库和编译一个 APK 文件都需要定义如何编译 Java 文件。因此，表 3 中的这些 Make 文件的定义中会包含一些共同的代码逻辑。为了减少代码冗余，需要将共同的代码复用起来，复用的方式是将共同代码放到专门的文件中，然后在其他文件中包含这 些文件的方式来实现的。这些包含关系如图 5 所示。由于篇幅关系，这里就不再对其他文件做详细描述（其实这些文件从文件名称中就可以大致猜出其作用）。<br><br>##### 图 5. 模块的编译方式定义文件的包含关系<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image005.png" alt="图 5\. 模块的编译方式定义文件的包含关系"><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## Make 目标说明<br><br>### make /make droid<br><br>如果在源码树的根目录直接调用“make”命令而不指定任何目标，则会选择默认目标：“droid”（在 main.mk 中定义）。因此，这和执行“make droid”效果是一样的。<br><br>droid 目标将编译出整个系统的镜像。从源代码到编译出系统镜像，整个编译过程非常复杂。这个过程并不是在 droid 一个目标中定义的，而是 droid 目标会依赖许多其他的目标，这些目标的互相配合导致了整个系统的编译。<br><br>图 6 描述了 droid 目标所依赖的其他目标：<br><br>##### 图 6. droid 目标所依赖的其他 Make 目标<br><br><img src="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/image006.png" alt="图 6\. droid 目标所依赖的其他 Make 目标">图 6 中这些目标的说明如表 4 所示：<br><br>##### 表 4. droid 所依赖的其他 Make 目标的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>apps_only</strong></td><br><td>该目标将编译出当前配置下不包含 user，userdebug，eng 标签（关于标签，请参见后文“添加新的模块”）的应用程序。</td><br></tr><br><tr><br><td><strong>droidcore</strong></td><br><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td><br></tr><br><tr><br><td><strong>dist_files</strong></td><br><td>该目标用来拷贝文件到 /out/dist 目录。</td><br></tr><br><tr><br><td><strong>files</strong></td><br><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td><br></tr><br><tr><br><td><strong>prebuilt</strong></td><br><td>该目标依赖于 <code>$(ALL_PREBUILT)</code>，<code>$(ALL_PREBUILT)</code>的作用就是处理所有已编译好的文件。</td><br></tr><br><tr><br><td><strong><code>$(modules_to_install)</code></strong></td><br><td>modules_to_install 变量包含了当前配置下所有会被安装的模块（一个模块是否会被安装依赖于该产品的配置文件，模块的标签等信息），因此该目标将导致所有会被安装的模块的编译。</td><br></tr><br><tr><br><td><strong><code>$(modules_to_check)</code></strong></td><br><td>该目标用来确保我们定义的构建模块是没有冗余的。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_ANDROID_INFO_TXT_TARGET)</code></strong></td><br><td>该目标会生成一个关于当前 Build 配置的设备信息的文件，该文件的生成路径是：out/target/product/&lt;_product_name</td></tr></tbody></table></em>&gt;/android-info.txt<br><br><tr><br><td><strong>systemimage</strong></td><br><td>生成 system.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_BOOTIMAGE_TARGET)</code></strong></td><br><td>生成 boot.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_RECOVERYIMAGE_TARGET)</code></strong></td><br><td>生成 recovery.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_USERDATAIMAGE_TARGET)</code></strong></td><br><td>生成 userdata.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_CACHEIMAGE_TARGET)</code></strong></td><br><td>生成 cache.img。</td><br></tr><br><tr><br><td><strong><code>$(INSTALLED_FILES_FILE)</code></strong></td><br><td>该目标会生成 out/target/product/&lt;<em>product_name</em>&gt;/ installed-files.txt 文件，该文件中内容是当前系统镜像中已经安装的文件列表。</td><br></tr><br><br><br><br>### 其他目标<br><br>Build 系统中包含的其他一些 Make 目标说明如表 5 所示：<br><br>##### 表 5. 其他主要 Make 目标<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>Make 目标</th><br><th>说明</th><br></tr><br><tr><br><td><strong>make clean</strong></td><br><td>执行清理，等同于：rm -rf out/。</td><br></tr><br><tr><br><td><strong>make sdk</strong></td><br><td>编译出 Android 的 SDK。</td><br></tr><br><tr><br><td><strong>make clean-sdk</strong></td><br><td>清理 SDK 的编译产物。</td><br></tr><br><tr><br><td><strong>make update-api</strong></td><br><td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的 API 记录在 frameworks/base/api 目录下。</td><br></tr><br><tr><br><td><strong>make dist</strong></td><br><td>执行 Build，并将 MAKECMDGOALS 变量定义的输出文件拷贝到 /out/dist 目录。</td><br></tr><br><tr><br><td><strong>make all</strong></td><br><td>编译所有内容，不管当前产品的定义中是否会包含。</td><br></tr><br><tr><br><td><strong>make help</strong></td><br><td>帮助信息，显示主要的 make 目标。</td><br></tr><br><tr><br><td><strong>make snod</strong></td><br><td>从已经编译出的包快速重建系统镜像。</td><br></tr><br><tr><br><td><strong>make libandroid_runtime</strong></td><br><td>编译所有 JNI framework 内容。</td><br></tr><br><tr><br><td><strong>make**</strong>framework<strong></strong></td><br><td>编译所有 Java framework 内容。</td><br></tr><br><tr><br><td>make<strong>**services</strong></td><br><td>编译系统服务和相关内容。</td><br></tr><br><tr><br><td><strong>make &lt;local_target&gt;</strong></td><br><td>编译一个指定的模块，local_target 为模块的名称。</td><br></tr><br><tr><br><td><strong>make clean-&lt;local_target&gt;</strong></td><br><td>清理一个指定模块的编译结果。</td><br></tr><br><tr><br><td><strong>make**</strong>dump-products<strong></strong></td><br><td>显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息。</td><br></tr><br><tr><br><td>make<strong>**PRODUCT-xxx-yyy</strong></td><br><td>编译某个指定的产品。</td><br></tr><br><tr><br><td><strong>make**</strong>bootimage<strong></strong></td><br><td>生成 boot.img</td><br></tr><br><tr><br><td>make<strong>**recoveryimage</strong></td><br><td>生成 recovery.img</td><br></tr><br><tr><br><td><strong>make**</strong>userdataimage<strong></strong></td><br><td>生成 userdata.img</td><br></tr><br><tr><br><td>make<strong>**cacheimage</strong></td><br><td>生成 cache.img</td><br></tr><br></tbody><br></table><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 在 Build 系统中添加新的内容<br><br>### 添加新的产品<br><br>当我们要开发一款新的 Android 产品的时候，我们首先就需要在 Build 系统中添加对于该产品的定义。<br><br>在 Android Build 系统中对产品定义的文件通常位于 device 目录下（另外还有一个可以定义产品的目录是 vender 目录，这是个历史遗留目录，Google 已经建议不要在该目录中进行定义，而应当选择 device 目录）。device 目录下根据公司名以及产品名分为二级目录，这一点我们在概述中已经提到过。<br><br>通常，对于一个产品的定义通常至少会包括四个文件：AndroidProducts.mk，产品版本定义文件，BoardConfig.mk 以及 verndorsetup.sh。下面我们来详细说明这几个文件。<br><br>*   AndroidProducts.mk：该文文件中的内容很简单，其中只需要定义一个变量，名称为“PRODUCT_MAKEFILES”，该变量的值为产品版本定义文件名的列表，例如：<br><div><br><pre> PRODUCT_MAKEFILES := \<br> $(LOCAL_DIR)/full_stingray.mk \<br> $(LOCAL_DIR)/stingray_emu.mk \<br> $(LOCAL_DIR)/generic_stingray.mk</pre><br></div>

<ul>
<li>产品版本定义文件：顾名思义，该文件中包含了对于特定产品版本的定义。该文件可能不只一个，因为同一个产品可能会有多种版本（例如，面向中国地区一个版本，面向美国地区一个版本）。该文件中可以定义的变量以及含义说明如表 6 所示：</li>
</ul>
<h5 id="表_6-_产品版本定义文件中的变量及其说明">表 6. 产品版本定义文件中的变量及其说明</h5><p><table summary="" border="0" cellspacing="0" cellpadding="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><th>常量</th></p>
<p><th>说明</th><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_NAME</strong></td></p>
<p><td>最终用户将看到的完整产品名，会出现在“关于手机”信息中。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_MODEL</strong></td></p>
<p><td>产品的型号，这也是最终用户将看到的。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_LOCALES</strong></td></p>
<p><td>该产品支持的地区，以空格分格，例如：en_GB de_DE es_ES fr_CA。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PACKAGES</strong></td></p>
<p><td>该产品版本中包含的 APK 应用程序，以空格分格，例如：Calendar Contacts。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_DEVICE</strong></td></p>
<p><td>该产品的工业设计的名称。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_MANUFACTURER</strong></td></p>
<p><td>制造商的名称。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_BRAND</strong></td></p>
<p><td>该产品专门定义的商标（如果有的话）。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PROPERTY_OVERRIDES</strong></td></p>
<p><td>对于商品属性的定义。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_COPY_FILES</strong></td></p>
<p><td>编译该产品时需要拷贝的文件，以“源路径 : 目标路径”的形式。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_OTA_PUBLIC_KEYS</strong></td></p>
<p><td>对于该产品的 OTA 公开 key 的列表。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_POLICY</strong></td></p>
<p><td>产品使用的策略。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_PACKAGE_OVERLAYS</strong></td></p>
<p><td>指出是否要使用默认的资源或添加产品特定定义来覆盖。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_CONTRIBUTORS_FILE</strong></td></p>
<p><td>HTML 文件，其中包含项目的贡献者。</td><br></p>
<p><tr></tr></p>
<p><td><strong>PRODUCT_TAGS</strong></td></p>
<p><td>该产品的标签，以空格分格。</td><br><br><br><br>通常情况下，我们并不需要定义所有这些变量。Build 系统的已经预先定义好了一些组合，它们都位于 /build/target/product 下，每个文件定义了一个组合，我们只要继承这些预置的定义，然后再覆盖自己想要的变量定义即可。例如：</p>
<div><br><pre> # 继承 full_base.mk 文件中的定义<br> $(call inherit-product, $(SRC_TARGET_DIR)/product/full_base.mk)<br> # 覆盖其中已经定义的一些变量<br> PRODUCT_NAME := full_lt26<br> PRODUCT_DEVICE := lt26<br> PRODUCT_BRAND := Android<br> PRODUCT_MODEL := Full Android on LT26</pre><br></div>

<ul>
<li>BoardConfig.mk：该文件用来配置硬件主板，它其中定义的都是设备底层的硬件特性。例如：该设备的主板相关信息，Wifi 相关信息，还有 bootloader，内核，radioimage 等信息。对于该文件的示例，请参看 Android 源码树已经有的文件。</li>
<li>vendorsetup.sh：该文件中作用是通过 add_lunch_combo 函数在 lunch 函数中添加一个菜单选项。该函数的参数是产品名称加上编译类型，中间以“-”连接，例如：add_lunch_combo full_lt26-userdebug。/build/envsetup.sh 会扫描所有 device 和 vender 二 级目 录下的名称 为”vendorsetup.sh”文件，并根据其中的内容来确定 lunch 函数的 菜单选项。<br>在配置了以上的文件之后，便可以编译出我们新添加的设备的系统镜像了。</li>
</ul>
<p>首先，调用“<code>source build/envsetup.sh</code>”该命令的输出中会看到 Build 系统已经引入了刚刚添加的 vendorsetup.sh 文件。</p>
<p>然后再调用“lunch”函数，该函数输出的列表中将包含新添加的 vendorsetup.sh 中添加的条目。然后通过编号或名称选择即可。</p>
<p>最后，调用“make -j8”来执行编译即可。</p>
<h3 id="添加新的模块">添加新的模块</h3><p>关于“模块”的说明在上文中已经提到过，这里不再赘述。</p>
<p>在 源码树中，一个模块的所有文件通常都位于同一个文件夹中。为了将当前模块添加到整个 Build 系统中，每个模块都需要一个专门的 Make 文件，该文件的名称为“Android.mk”。Build 系统会扫描名称为“Android.mk”的文件，并根据该文件中内容编译出相应的产物。</p>
<p>需 要注意的是：在 Android Build 系统中，编译是以模块（而不是文件）作为单位的，每个模块都有一个唯一的名称，一个模块的依赖对象只能是另外一个模块，而不能是其他类型的对象。对于已经 编译好的二进制库，如果要用来被当作是依赖对象，那么应当将这些已经编译好的库作为单独的模块。对于这些已经编译好的库使用 BUILD_PREBUILT 或 BUILD_MULTI_PREBUILT。例如：当编译某个 Java 库需要依赖一些 Jar 包时，并不能直接指定 Jar 包的路径作为依赖，而必须首先将这些 Jar 包定义为一个模块，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。</p>
<p>下面，我们就来讲解 Android.mk 文件的编写：</p>
<p>Android.mk 文件通常以以下两行代码作为开头：</p>
<div><br><pre> LOCAL_PATH := $(call my-dir)<br> include $(CLEAR_VARS)</pre><br></div><br>这两行代码的作用是：<br><br>1.  设置当前模块的编译路径为当前文件夹路径。<br>2.  清理（可能由其他模块设置过的）编译环境中用到的变量。<br>为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。它们包括：<br><br><em>   LOCAL_SRC_FILES：当前模块包含的所有源代码文件。
</em>   LOCAL_MODULE：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。<br><em>   LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。
</em>   LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。<br><em>   LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。
</em>   LOCAL_CFLAGS：提供给 C/C++ 编译器的额外编译参数。<br><em>   LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。
</em>   LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。<br><em>   LOCAL_PACKAGE_NAME：当前 APK 应用的名称。
</em>   LOCAL_CERTIFICATE：签署当前应用的证书名称。<br><em>   LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。标签的值可能是 debug, eng, user，development 或者 optional。其中，optional 是默认标签。标签是提供给编译类型使用的。不同的编译类型会安装包含不同标签的模块，关于编译类型的说明如表 7 所示：<br><br>##### 表 7. 编译类型的说明<br><br><table summary="" border="0" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><th>名称</th><br><th>说明</th><br></tr><br><tr><br><td><strong>eng</strong></td><br><td>默认类型，该编译类型适用于开发阶段。<br>当选择这种类型时，编译结果将：

</td></tr></tbody></table></em>   安装包含 eng, debug, user，development 标签的模块<br><em>   安装所有没有标签的非 APK 模块
</em>   安装所有产品定义文件中指定的 APK 模块<br><br><br><tr><br><td><strong>user</strong></td><br><td>该编译类型适合用于最终发布阶段。<br>当选择这种类型时，编译结果将：<br><br><em>   安装所有带有 user 标签的模块
</em>   安装所有没有标签的非 APK 模块<br><em>   安装所有产品定义文件中指定的 APK 模块，APK 模块的标签将被忽略<br></em></td><br></tr><br><tr><br><td><strong>userdebug</strong></td><br><td>该编译类型适合用于 debug 阶段。<br>该类型和 user 一样，除了：

   会安装包含 debug 标签的模块<br><em>   编译出的系统具有 root 访问权限<br></em></td><br></tr><br><br><br>表 3 中的文件已经定义好了各种类型模块的编译方式。所以要执行编译，只需要引入表 3 中对应的 Make 文件即可（通过常量的方式）。例如，要编译一个 APK 文件，只需要在 Android.mk 文件中，加入“<code>include $(BUILD_PACKAGE)</code><br><br>除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括：

   <code>$(call my-dir)</code>：获取当前文件夹路径。<br><em>   <code>$(call all-java-files-under, &amp;lt;src&amp;gt;)</code>：获取指定目录下的所有 Java 文件。
</em>   <code>$(call all-c-files-under, &amp;lt;src&amp;gt;)</code>：获取指定目录下的所有 C 语言文件。<br><em>   <code>$(call all-Iaidl-files-under, &amp;lt;src&amp;gt;)</code> ：获取指定目录下的所有 AIDL 文件。
</em>   <code>$(call all-makefiles-under, &amp;lt;folder&amp;gt;)</code>：获取指定目录下的所有 Make 文件。<br>*   <code>$(call intermediates-dir-for, &amp;lt;class&amp;gt;, &amp;lt;app_name&amp;gt;, &amp;lt;host or target&amp;gt;, &amp;lt;common?&amp;gt; )</code>：获取 Build 输出的目标文件夹路径。<br>清单 2 和清单 3 分别是编译 APK 文件和编译 Java 静态库的 Make 文件示例：<br><br>##### 清单 2. 编译一个 APK 文件<br><br><div><br><pre>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)<br>  # 获取所有子目录中的 Java 文件<br>  LOCAL_SRC_FILES := $(call all-subdir-java-files)<br>  # 当前模块依赖的静态 Java 库，如果有多个以空格分隔<br>  LOCAL_STATIC_JAVA_LIBRARIES := static-library<br>  # 当前模块的名称<br>  LOCAL_PACKAGE_NAME := LocalPackage<br>  # 编译 APK 文件<br>  include $(BUILD_PACKAGE)</pre><br></div>

<h5 id="清单_3-_编译一个_Java_的静态库">清单 3. 编译一个 Java 的静态库</h5><div><br><pre>  LOCAL_PATH := $(call my-dir)<br>  include $(CLEAR_VARS)<br><br>  # 获取所有子目录中的 Java 文件<br>  LOCAL_SRC_FILES := $(call all-subdir-java-files)<br><br>  # 当前模块依赖的动态 Java 库名称<br>  LOCAL_JAVA_LIBRARIES := android.test.runner<br><br>  # 当前模块的名称<br>  LOCAL_MODULE := sample<br><br>  # 将当前模块编译成一个静态的 Java 库<br>  include $(BUILD_STATIC_JAVA_LIBRARY)</pre><br></div><br><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#ibm-pcon" target="_blank" rel="external">回页首</a><br><br>## 结束语<br><br>整个 Build 系统包含了非常多的内容，由于篇幅所限，本文只能介绍其中最主要内容。<br><br>由于 Build 系统本身也是在随着 Android 平台不断的开发过程中，所以不同的版本其中的内容和定义可能会发生变化。网络上关于该部分的资料很零碎，并且很多资料中的一些内容已经过时不再适用，再加上缺少官方文档，所以该部分的学习存在一定的难度。<br><br>这就要求我们要有很强的代码阅读能力，毕竟代码是不会说谎的。 要知道，对于我们这些开发人员来说，源代码就是我们最忠实的朋友。 Use the Source,Luke!<br><br></div><br></div>

<h2 id="参考资料">参考资料</h2><h3 id="学习">学习</h3><ul>
<li><a href="http://source.android.com" target="_blank" rel="external">Android Open Source Project</a>：Android Source 官方网站。</li>
<li><a href="http://people.linaro.org/%7Easac/build-system.html" target="_blank" rel="external">Android Build System</a>：Build 系统中包含的说明文档。</li>
<li><a href="http://www.gnu.org/software/make/manual/html_node/index.html" target="_blank" rel="external">GNU `make’</a>：GNU make 官方手册。</li>
<li><a href="http://elinux.org/Android_Device" target="_blank" rel="external">Android Device</a>：大致介绍了 Build 系统中的一些文件。</li>
<li><a href="https://sites.google.com/a/itspaclub.com/www/android/android-build-system-anatomy" target="_blank" rel="external">Build System</a>：另一个关于 Build 系统的说明资料。</li>
<li><a href="http://www.android-x86.org/documents/how-to-add-new-x86-platforms" target="_blank" rel="external">Add new target</a>：该文档描述了如何添加一个新的产品目标。<br>&nbsp;</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/07/linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b/" class="article-date">
  	<time datetime="2014-08-07T08:26:52.000Z" itemprop="datePublished">2014-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/07/linux-e5-a6-82-e4-bd-95-e6-9d-80-e6-ad-bb-e5-83-b5-e5-b0-b8-e8-bf-9b-e7-a8-8b/">linux 如何杀死僵尸进程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自blog.51osos.com/linux/linux-how-to-kill-zombie-process/<br>In UNIX System terminology, a process that has terminated,but whose parent has not yet waited for it, is called a zombie.<br>在UNIX 系统中,一个进程结束了,但是他的父进程没有等待(调用wait / waitpid)他, 那么他将变成一个僵尸进程. 在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用 waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵尸进程。<br>如何查看linux系统上的僵尸进程，如何统计有多少僵尸进程？</p>
<h1 id="ps_-ef_|_grep_defunct">ps -ef | grep defunct</h1><p>或者查找状态为Z的进程，Z就是代表zombie process,僵尸进程的意思。<br>另外使用top命令查看时有一栏为S,如果状态为Z说明它就是僵尸进程。<br>Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie<br>top命令中也统计了僵尸进程。或者使用下面的命令：<br>ps -ef | grep defunct | grep -v grep | wc -l<br>如何杀死僵尸进程呢？<br>一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。<br>ps -e -o ppid,stat | grep Z | cut -d” ” -f2 | xargs kill -9<br>或<br>kill -HUP <code>ps -A -ostat,ppid | grep -e ’^[Zz]‘ | awk ’{print $2}’</code><br>当然您可以自己编写更好的shell脚本，欢迎与大家分享。<br>另外子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子进程收尸。就是基于这样的原理：就算父进程没有调用wait，内核也会向它发送SIGCHLD消息，而此时，尽管对它的默认处理是忽略，如果想响应这个消息，可以设置一个处理函数。<br>如何避免僵尸进程呢？<br>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结 束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下 可以简单地将 SIGCHLD信号的操作设为SIG_IGN。<br>signal(SIGCHLD,SIG_IGN);<br>这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程<br>或者<br>用两次fork()，而且使紧跟的子进程直接退出，是的孙子进程成为孤儿进程，从而init进程将负责清除这个孤儿进程。<br>本文水平有限，关于zombie更深层次的理解欢迎在评论中与大家分享。<br>Tags: zombie<br>wmflw on 2013 年 9 月 25 日 at 下午 4:21 said:<br>ps -ef | grep defunct | grep -v grep | awk ‘{print “kill -9 “ $2,$3}’<br>一条自动命令，试了下还不错的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a><a class="article-category-link" href="/categories/杂七杂八/网摘/">网摘</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/29/e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop/" class="article-date">
  	<time datetime="2014-04-29T15:16:24.000Z" itemprop="datePublished">2014-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/29/e4-b8-80-e8-b5-b7-e6-9d-a5-e7-8e-a9hadoop/">一起来玩hadoop</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""> </h1><pre><code>1 使用百度开放研究社区
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度提供了开放研究社区，这里我们可以用一个百度的hadoop资源，就不需要你自己搭建hadoop了，这多爽啊！下面我们来使用使用这个东西。</span><br></div>

<h2 id="-1"> </h2><h2 id="-2"> </h2><pre><code>1<span class="class">.2</span> 打开百度开放研究社区的<span class="tag">web</span> <span class="tag">Shell</span>
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度提供了一种类似shell的方式来提供交互。</span><br></div><br><div><br>    <span style="font-size:14px">我们在申请账号之后，进入到这个网页去看说明&nbsp;<a href="http://openresearch.baidu.com/activity/platform.jspx" target="_blank" rel="external">http://openresearch.baidu.com/activity/platform.jspx&nbsp;</a></span><br></div>

<h1 id="-3"> </h1><h1 id="-4"> </h1><pre><code>2 使用百度云平台
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">百度的这个云平台网址是<span style="font-family:times; orphans:0; text-indent:32px; widows:0"><a href="http://cc-ws.baidu.com" target="_blank" rel="external">http://cc-ws.baidu.com</a>，进入web shell之后如下图</span></span><br></div><br><div><br>    <span style="font-family:times; font-size:14px; orphans:0; text-indent:32px; widows:0"><img src="http://img.blog.csdn.net/20140429223342312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br></div><br><div><br>    <span style="font-family:times; orphans:0; text-indent:32px; widows:0"><span style="font-size:14px; white-space:pre"></span><span style="font-size:12px">图1 web shell</span></span><br></div><br><div><br>    <span style="font-family:times; orphans:0; text-indent:32px; widows:0"><span style="font-size:14px">这个可以认为是一个类unix的操作界面吧，不过这里只支持这些命令，下面主要讲讲用这个来进行一些hadoop的经典入门——wordCount</span></span><br></div>

<h2 id="-5"> </h2><pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-family:times; orphans:0; text-indent:32px; widows:0"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-size:14px"</span>&gt;</span>

<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><h2 id="-6"> </h2><pre><code><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-family:times; orphans:0; text-indent:32px; widows:0"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-size:14px"</span>&gt;</span>2.1 生成count所需的文件并且上传到百度的hadoop环境<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><div><br>    <span style="font-size:14px"><br><br>    </span><br></div><br><div><br>    <span style="font-size:14px">由于这个百度自带的upload和download命令有点不好用，所以我用从自己的百度网盘里面搞数据过来，我在我的网盘里面上传了两个文件f1.txt,f2.txt</span><br></div><br><div><br>    <span style="font-size:14px"></span><br>    <pre lang="shell">hello world<span style="white-space:pre">    </span>#f1.txt</pre><br>    <div><br>        <span style="font-size:14px"><br><br>        </span><br>    </div><br>    <pre lang="shell">hello programmer<span style="white-space:pre">    </span>#f2.txt</pre><br><br>    然后通过命令把文件同步到hdfs上<br></div><br><div><br>    <span style="font-size:14px"></span><br>    &lt;pre lang=”shell””&gt;pan -put ./f*.txt ./input<br>    把网盘的两个文件都同步到hdfs目录下的input目录里面<br></div><br><div><br>    <span style="font-size:14px">然后使用</span><br></div><br><div><br>    <span style="font-size:14px"></span><br>    <pre lang="shell">hadoop fs -ls ./input</pre><br>    查看，结果如下<br></div><br><div><br>    <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429224934312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>    图2 结果已同步到hdfs上（涂掉的部分是我的用户名）<br><br>    </span><br><br>##<br>        <span style="font-size:14px"><br><br>        </span><br><br>##<br>        <span style="font-size:14px">2.2 使用自带的wordcount例子来运行wordcount</span><br><br>    <div><br>        <span style="font-size:14px"><br><br>        </span><br>    </div><br>    <div><br>        <span style="font-size:14px">百度的云平台有三个全局变量，hadoop命令如下介绍</span><br>    </div><br>    <div><br>        <span style="font-size:14px"></span><br>        <pre lang="shell">Hadoop命令<br>■ hadoop: 用于访问Hadoop的功能，其使用方式与命令行使用hadoop的方式一致。对于普通用户权限，其能够使用的hadoop命令包括hadoop fs，hadoop jar，hadoop job等。相对于hadoop命令的本地文件系统的当前路径即为用户的工作目录。为了访问hadoop系统的某些模块，平台也提供了三个变量可以直接使用，包括：$hadoop_home（hadoop系统的根目录）；$hadoop_examples（hadoop-examples-1.0.0.jar的路径），$hadoop_streaming（hadoop-streaming-1.0.0.jar的路径）</pre><br><br>        我们只需要执行下面的命令就可以统计了<br>    </div><br>    <div><br>        <span style="font-size:14px"></span><br>        <pre lang="shell">hadoop jar $hadoop_examples wordcount input output</pre><br>        运行结果如下<br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429225722859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        图三 这个是wordcount运行结果</span><br>    </div><br>    <div><br>        <span style="font-size:14px">我们进入output文件夹查看结果</span><br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429230101078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        </span><br>    </div><br>    <div><br>        <span style="font-size:14px">图四 这个是计算出来的结果，结果放在part-r-00000</span><br>    </div><br>    <div><br>        <span style="font-size:14px"><img src="http://img.blog.csdn.net/20140429230337937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenBsODkxMDEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br>        </span><br>    </div><br>    <span style="font-size:14px">这下把这些单词统计过来了。</span><br></div><br><div><br>    <span style="font-size:14px">下次准备在本地写一个本地版本的wordcount，然后上传上来玩玩</span><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/28/e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6/" class="article-date">
  	<time datetime="2014-04-28T14:01:41.000Z" itemprop="datePublished">2014-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/28/e9-ab-98-e5-8f-af-e7-94-a8mysql-e5-ad-a6-e4-b9-a0-e4-b9-8b-e8-b7-af-ef-bc-88-e4-b8-80-ef-bc-89-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-bamysql-e5-a4-8d-e5-88-b6/">高可用MYSQL学习之路（一）——环境搭建&amp;mysql复制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id=""> </h1><pre><code>1.资源概述
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>由于实验室机器太少，手上只有一个服务器和自己的小笔记本，一直想玩玩这种感觉高大上的mysql集群，今天终于下定决心进行。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>在这里，我遇到了两个问题，先给大家阐述一下，希望能帮助大家</span><br></div><br><div><br><br><em>   <span style="font-size:18px;"><span style="white-space:pre">    </span>一台机器里面如何装多个mysql</span>
</em>   <span style="font-size:18px;"><span style="white-space:pre">    </span>为复制而创建的用户不能本地登录</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面围绕这两个问题进行解决。</span><br></div>

<h1 id="-1"> </h1><pre><code>2.如何在一台机器里面安装多个mysql
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>显然这个是开多个mysql的实例，只是对应着不同的端口就可以轻松达成。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面讲讲我的做法。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>1. 下载mysql源码，我这里下载的是mysql5.5.32的</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>2. 使用牛叉的cmake、make、make install进行安装</span><br></div><br><div><br>    <span style="white-space:pre">        </span><span style="font-size:24px;"><strong>安装第一个实例mysql1</strong></span><br></div><br><div><br>    <span style="white-space:pre">        </span>首先cmake<br></div><br><div><br>    <span style="white-space:pre">        </span><br>    <pre lang="shell">cmake \<br>-DCMAKE_INSTALL_PREFIX=/data/mysql1 \   #安装路径<br>-DMYSQL_DATADIR=/data/mysql1/data       \    #数据文件存放位置<br>-DSYSCONFDIR=/etc              \                                  #my.cnf路径<br>-DWITH_MYISAM_STORAGE_ENGINE=1    \       #支持MyIASM引擎<br>-DWITH_INNOBASE_STORAGE_ENGINE=1 \     #支持InnoDB引擎<br>-DWITH_MEMORY_STORAGE_ENGINE=1 \        #支持Memory引擎<br>-DWITH_READLINE=1                    \                         #快捷键功能(我没用过)<br>-DMYSQL_UNIX_ADDR=/data/mysql1/mysql1.sock      \   #连接数据库socket路径<br>-DMYSQL_TCP_PORT=3306                  \               #端口<br>-DENABLED_LOCAL_INFILE=1            \                #允许从本地导入数据<br>-DWITH_PARTITION_STORAGE_ENGINE=1  \   #安装支持数据库分区<br>-DEXTRA_CHARSETS=all                  \                   #安装所有的字符集<br>-DDEFAULT_CHARSET=utf8              \                   #默认字符<br>-DDEFAULT_COLLATION=utf8_general_ci</pre><br></div><br><div><br>    <span style="white-space:pre">        <span style="font-size:18px;">执行完毕之后我们然后make &amp; make install</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="white-space:pre">        </span><strong><span style="font-size:24px;">这样我们的mysql就安装好了。</span></strong></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style=" white-space: pre; "><strong>    </strong></span>然后我们需要做的事情就是为这个实例写一个配置文件</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">    </span>3. 为我们的这个实例搞一个配置文件</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">        </span>配置文件这个东西其实mysql都准备好了的，我们只需要拿出来改一改，进入到我们的安装目录/data/mysql1,将support-file文件夹下的my-medium.cnf作为我们的配置文件吧，</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space: pre; ">    </span>我将my-medium.cnf拷贝到了/data/mysql1目录下，并重命名为my.cnf，命令如下</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:14px;"><span style="white-space:pre">    </span></span></span><br>    <pre lang="shell">cp my-medium.cnf ../my.cnf</pre><br>    <span style="white-space:pre">    </span>打开我们的my.cnf，我们主要是需要改如下几个地方<br></div><br><div><br>    <span style="white-space:pre"></span><br>    <pre lang="shell">[client]<br>#password       = your_password<br><span style="font-size:24px;color:#999900;"><strong>port            = 3308<br>socket          = /data/mysql1/mysql1.sock</strong></span><span style="font-size:14px;"><br><br># Here follows entries for some specific programs<br><br># The MySQL server<br>[mysqld]<br></span><strong><span style="font-size:24px;color:#cc6600;">port            = 3308<br>socket          = /data/mysql1/mysql1.sock</span></strong><span style="font-size:14px;"><br>skip-external-locking<br>key_buffer_size = 16M<br>max_allowed_packet = 1M<br>table_open_cache = 64<br>sort_buffer_size = 512K<br>net_buffer_length = 8K<br>read_buffer_size = 256K<br>read_rnd_buffer_size = 512K<br>myisam_sort_buffer_size = 8M<br><br># Don’t listen on a TCP/IP port at all. This can be a security enhancement,<br># if all processes that need to connect to mysqld run on the same host.<br># All interaction with mysqld must be made via Unix sockets or named pipes.<br># Note that using this option without enabling named pipes on Windows<br># (via the &quot;enable-named-pipe&quot; option) will render mysqld useless!<br>#<br>#skip-networking<br><br># Replication Master Server (default)<br># binary logging is required for replication<br>log-bin=mysql1-bin<br><br># binary logging format - mixed recommended<br>binlog_format=mixed<br><br># required unique id between 1 and 2^32 - 1<br># defaults to 1 if master-host is not set<br># but will not function as a master if omitted<br></span><strong><span style="font-size:24px;background-color: rgb(255, 102, 0);">server-id       = 2</span></strong><span style="font-size:14px;"><br></span></pre><br><br>    <span style="font-size:18px;"><span style="white-space: pre; ">    </span>port不用说了，这个肯定是为每一个mysql确定一个端口，socket这个是指每个mysql实例需要用的sock文件，server-id这个是全局统一的id号，不可以出现重复的，这三个地方是需要注意的。</span><br></div><br><div><br>    <span style="white-space:pre"><span style="white-space:pre"><span style="font-size:18px;">    </span></span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space:pre">    </span>4. 配置文件更改完毕之后，我们对mysql这个实例进行初始化</span></span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;"><span style="white-space: pre; ">    </span>进入到scripts文件夹下，运行下面的命令</span></span><br></div><br><div><br>    <span style="white-space:pre"></span><br>    <pre lang="shell">./mysql_install_db —defaults-file=/data/mysql1/my.cnf —basedir=/data/mysql1 —datadir=/data/mysql1/data —user=mysql</pre><br>    <span style="font-size:14px;"><br><br>    </span><span style="font-size:14px; white-space: pre; ">    </span><span style="font-size:18px;">—defaults-file是指我们刚刚修改的配置文件，</span><strong><span style="font-size:32px;color:#ff0000;">注意这里必须要用绝对路径，用相对路径就是个坑，坑爆了。</span></strong><br></div><br><div><br>    <span style="font-size: 14px; white-space: pre; ">    </span><span style="font-size:18px;">—basedir是指我们的这个实例所在的安装目录。</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>—datadir是指我们这个实例以后放数据的文件夹</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space: pre; ">    </span>5.这个脚本执行成功之后，我们进入到其bin的文件夹下准备启动它</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>执行以下命令</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">./mysqld_safe —defaults-file=/data/mysql1/my.cnf<br></pre><br>    <span style="white-space:pre">    </span>一般的情况下，我们不出意外就可以启动它了<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>6.设置root的密码和远程访问的权限</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">./mysqladmin -P 3308 -S /data/mysql1/mysql1.sock -u root password</pre><br>    <span style="white-space:pre">    </span>由于我们是多个实例，所以我们需要随时指定-P端口 -S sock文件<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>为了方便，我自己写了两个小脚本进行处理，入参如下</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>第一个脚本runSQL.sh，主要是进行关闭和启动mysql的</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第一个参数是实例编号，像上面我们在/data/mysql1所以编号是1；</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第二个参数是命令，shutdown和start，分别控制启动和关闭</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第三个参数是端口号</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>以上三个参数都需要加上</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="shell">dir=’/data/mysql’;<br>para=$1;<br>port=$3;<br>#echo $para;<br>sqlBasedir=$dir$para;<br>sqlDatadir=$sqlBasedir’/data’;<br>sqlRundir=$sqlBasedir’/bin’;<br>sqlConfigdir=$sqlBasedir’/my.cnf’;<br>sqlRunSock=$sqlBasedir’/mysql’$para’.sock’;<br>echo $2;<br>echo $sqlRundir;<br>cmd=&quot;start&quot;;<br>if [ &quot;$cmd&quot;x = &quot;$2&quot;x ];then<br>  echo ‘start’;<br>  $sqlRundir/mysqld_safe —defaults-file=$sqlConfigdir —user=mysql&amp;<br>  echo ‘ok’;<br>#echo $sqlBasedir;<br>#echo $sqlDatadir;<br>else<br>  echo ‘shutdown’;<br>  $sqlRundir/mysqladmin -P $port -S $sqlRunSock -uroot -p shutdown;<br>fi<br></pre><br><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre"><span style="white-space:pre">    </span>第二个</span>脚本是enterSQL.sh，主要是通过root账号进入到mysql控制台</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第一个参数是实例编号，意义同上一个脚本</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span>第二个参数是端口号</span><br></div><br><div><br>    <span style="font-size:18px;"></span><br>    <pre lang="shell">dir=’/data/mysql’;<br>para=$1;<br>port=$2;<br>#echo $para;<br>sqlBasedir=$dir$para;<br>sqlDatadir=$sqlBasedir’/data’;<br>sqlRundir=$sqlBasedir’/bin’;<br>sqlConfigdir=$sqlBasedir’/my.cnf’;<br>sqlRunSock=$sqlBasedir’/mysql’$para’.sock’;<br>$sqlRundir/mysql -P $port -S $sqlRunSock -uroot -p ;<br></pre><br><br>    <span style="white-space:pre">    </span>这下我们安装好了一个区别于一般情况的mysql实例了。<br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>下面只需要重复上面的步骤，分别把上面my.cnf中的红色的地方换掉就可以了。</span><br></div>

<h1 id="-2"> </h1><pre><code>3.新建的用户不能本地登录
</code></pre><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span>一开始我为主从复制创建了一个新的用户，<strong>结果我发现，新创建的用户是不能本地登录的！以至于我的slave总是连接不上master而不能进行复制操作。</strong></span><br></div><br><div><br>    <strong><span style="font-size:18px;"><span style="white-space:pre">    </span>参考下文</span></strong><br></div><br><div><br>    <span style="font-size:18px;"><span style="font-weight: bold; white-space: pre; ">    </span><a href="http://hi.baidu.com/dspace/item/11dd1b08a89710103a53eec4" target="_blank" rel="external">mysql新建用户无法登陆解决办法</a></span><br></div>

<h1 id="-3"> </h1><pre><code>4.来做我们的主从复制吧~
</code></pre><div><br>    <span style="font-size:18px;">·<span style="white-space:pre">    </span>在master上创建一个复制账号并且授权</span><br></div><br><div><br>    <span style="white-space:pre"><span style="font-size:18px;">    </span></span><br>    <pre lang="sql">create user repl_user;<br>grant replication slave on <em>.</em> to repl_user@’%’ identified by ‘123456’;</pre><br><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre"><span style="white-space:pre">    </span>然后</span>在slave上进行如下配置</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">    </span></span><br>    <pre lang="sql">change master to master_host=’localhost’ master_port=3309 master_user=’repl_user’ master_password=’123456’</pre><br>    因为是在一台机器上所以host就是localhost，我选取的是一个端口为3309的mysql实例。<br></div><br><div><br>    <span style="font-size:18px;">执行完这句之后，然后执行</span><br></div><br><div><br>    <pre lang="sql"><span style="font-size:18px;">start slave</span></pre><br>    <span style="font-size:18px;"><br><br>    这样大功告成。</span><br></div><br><div><br>    <span style="font-size:18px;">有问题欢迎交流~</span><br></div><br><div><br>    <span style="font-size:18px;"><span style="white-space:pre">        </span></span><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/MYSQL/">MYSQL</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e5-b0-be-e9-80-92-e5-bd-92" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/04/08/e5-b0-be-e9-80-92-e5-bd-92/" class="article-date">
  	<time datetime="2014-04-08T14:41:28.000Z" itemprop="datePublished">2014-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/08/e5-b0-be-e9-80-92-e5-bd-92/">尾递归</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.什么是递归？</p>
<pre><code>递归就是自己调用自己

2.编译器是如何实现递归的？

编译器是通过栈来实现递归，其实编译器也是通过栈来实现函数调用的，为了明白递归，我们先来看看我们的程序是如何实现函数调用的吧。

下面我们看一个函数调用的栗子
</code></pre><p><pre>int adder(int x,int y)<br>{<br> return x+y;<br>}</pre></p>
<p>void call()<br>{<br> int x=2;<br> int y=3;<br> adder(x,y);<br>}<br>&nbsp;</p>
<pre><code>我们使用gcc编译成汇编（PS：要想明白一个程序是怎么运行的最好的方式还是看汇编吧）
</code></pre><p><pre>gcc -S test.c</pre><br>&nbsp;</p>
<pre><code>下面我们看看汇编片段
</code></pre><p><pre><br>.file   “recu.c”<br>        .text<br>        .globl  adder<br>        .type   adder, @function<br>adder:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        movl    %edi, -4(%rbp)<br>        movl    %esi, -8(%rbp)<br>        movl    -8(%rbp), %eax<br>        movl    -4(%rbp), %edx<br>        addl    %edx, %eax<br>        popq    %rbp<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   adder, .-adder<br>        .globl  call<br>        .type   call, @function<br>call:<br>.LFB1:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    $2, -4(%rbp)<br>        movl    $3, -8(%rbp)<br>        movl    -8(%rbp), %edx<br>        movl    -4(%rbp), %eax<br>        movl    %edx, %esi<br>        movl    %eax, %edi<br>        call    adder<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE1:<br>        .size   call, .-call<br>        .ident  “GCC: (GNU) 4.8.2”<br>        .section        .note.GNU-stack,””,@progbits</pre><br>&nbsp;</p>
<pre><code>擦！汇编怎么那么多看不懂的符号啊？！！真拙计！

**我们这里是r开头的，原因是我们使用的是<span class="number">64</span>位的操作系统**

为了读懂汇编，我还是先去复习了一下，首先先明白几个寄存器吧

在X86上，用户寄存器为<span class="number">eax</span>, <span class="number">ebx</span>, <span class="number">ecx</span>, <span class="number">edx</span>, <span class="literal">esi</span>, <span class="literal">edi</span>, <span class="literal">ebp</span>, <span class="literal">esp</span> 以及<span class="literal">eip</span>
</code></pre><p>eax、ebx、ecx以及edx寄存器作为通用寄存器，可以用来进行临时存储</p>
<pre><code>esi和<span class="keyword">edi</span>可以用来存储，但对操作字符串类的函数有其他意义，在很多字符串操作指令中,&amp;nbsp;<span class="keyword">DS</span>:ESI指向源串,而ES:<span class="keyword">EDI</span>指向目标串
</code></pre><p>ebp通常用来容纳当前栈帧（stack frame）的内存地址，esp保存栈顶地址<br>eip保存当前执行指令的内存地址。机器代码不能直接修改该寄存器，只能通过jmp和call指令族进行间接修改，实现循环，调用等</p>
<p>&nbsp;</p>
<pre><code>然后我们在明白一下重要术语：

栈帧：值得是<span class="literal">ebp</span>到<span class="literal">esp</span>的这一段内存区间，每一个函数的调用都会生成一个栈帧，这里面保存着函数里的变量和指令。

我们主要关心<span class="keyword">call</span>函数以及adder函数，所以单独拿出来

我们先来看<span class="keyword">call</span>函数：
</code></pre><p><pre><em>**</em>这里的栈类别是指的向下满栈<br>call:<br>.LFB1:<br>        .cfi_startproc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##这个表示函数的入口参见<a href="http://web.mit.edu/wwinnie/MacData/afs/athena/project/rhel-doc/3/rhel-as-en-3/cfi-directives.html" target="_blank" rel="external">.cfi_startproc</a> pushq   %rbp   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp寄存器入栈<br>        .cfi_def_cfa_offset 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##定义CFI（call frame information）的cfa(<span style="font-family:Arial, sans-serif;font-size:14px;background-color:#eeeeee;">Canonical Frame Address</span>)的偏移量,主要是由于push了%rbp造成的偏移量<br>        .cfi_offset 6, -16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##.cfi我也不明<br>        movq    %rsp, %rbp             ##把rsp的值搞到rbp中去，表示现在进入了新栈<br>        .cfi_def_cfa_register 6        ##说明现在的cfa register是rbp<br>        subq    $16, %rsp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##空出两个单位，根据程序，我们应该猜得到是为x、y变量提供空间，为毛是压16个字节？难道是内存对其？<br>        movl    $2, -4(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp下面的一个4字节定义为x的空间<br>        movl    $3, -8(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把rbp下面的第8个字节处定义成y的空间<br>        movl    -8(%rbp), %edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;##把x、y的地址赋给寄存器edx和eax，这两个是通用寄存器<br>        movl    -4(%rbp), %eax<br>        movl    %edx, %esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##又把他们送个esi、edi这里是为传值做准备<br>        movl    %eax, %edi<br>        call    adder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ##这里调用adder函数，同时这个指令暗含一个把当前栈顶压入栈<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc</pre><br>下面用图来说明<br>&nbsp; <a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/03/绘图1.png" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/03/绘图1.png" alt="" title="frame"></a> &nbsp;<br>&nbsp;<br>好了，下面我们来谈谈尾递归。<br>主要围绕下面一个方面<br>1.什么是尾递归？与递归有什么区别？<br>我们先来一段代码来看看这两者之间的区别<br>&nbsp;</p>
<p><pre>int fact(int n){<br>      if(n &lt;0) return 0;<br>      if(n ==0) return 1;<br>      if(n ==1) return 1;<br>      return n*fact(n-1);<br>}</pre></p>
<p>int facttail(int n,int a){<br>      if(n &lt;0) return 0;<br>      if(n ==0) return 1;<br>      if(n ==1) return a;</p>
<pre><code><span class="keyword">return</span> facttail(<span class="keyword">n</span>-1,<span class="keyword">n</span>*a);
</code></pre><p>}<br>&nbsp;<br>fact函数是递归版本，facttail函数是尾递归版本。<br>&nbsp;<br>我们在文章最初知道了函数调用是通过栈帧来实现的，因为<strong><span style="font-size:16px;">栈帧中需要保存运算的变量</span></strong>，在使用递归的时候，比如函数fact，如果n非常大的话，很显然栈帧会越来越多，直到撑爆内存，这显然是我们不乐意见到的。<br>但是我们来看factail这个函数，它也是使用递归来实现求n的阶乘，但是注意到，这个函数中，<strong><span style="font-size:18px;">其栈帧是没有变量需要保存的</span></strong>，这就是说我们的栈帧是不需要的，我们完全可以就在原来的栈帧上进行运算！！<br>于是乎C编译器抖了个机灵，它如果发现了你使用了尾递归，他就会自动帮你优化，现在我们来看着两个函数的汇编。<br>为了看着方便，我们把判断全部删除，如下<br>&nbsp;</p>
<p><pre>int fact(int n){<br>      return n*fact(n-1);<br>}</pre></p>
<p>int facttail(int n,int a){<br>      return facttail(n-1,n*a);<br>}<br>汇编代码如下：<br>&nbsp;<br>&nbsp;</p>
<p><pre>fact:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    %edi, -4(%rbp)<br>        movl    -4(%rbp), %eax<br>        subl    $1, %eax<br>        movl    %eax, %edi<br>        call    fact<br>        imull   -4(%rbp), %eax<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   fact, .-fact<br>        .globl  facttail<br>        .type   facttail, @function<br>facttail:<br>.LFB1:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    %edi, -4(%rbp)<br>        movl    %esi, -8(%rbp)<br>        movl    -4(%rbp), %eax<br>        imull   -8(%rbp), %eax<br>        movl    -4(%rbp), %edx<br>        subl    $1, %edx<br>        movl    %eax, %esi<br>        movl    %edx, %edi<br>        call    facttail<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br></pre><br>卧槽！怎么都是递归呢？和传说中主动优化的不一样呢？<br>&nbsp;<br>原来是我搞忘记加入优化参数了，现在把优化参数加上，汇编代码如下<br>&nbsp;</p>
<p><pre>.file   “fact.c”<br>        .text<br>        .p2align 4,,15<br>        .globl  fact<br>        .type   fact, @function<br>fact:<br>.LFB7:<br>        .cfi_startproc<br>        .p2align 4,,10<br>        .p2align 3<br>.L2:<br>        jmp     .L2<br>        .cfi_endproc<br>.LFE7:<br>        .size   fact, .-fact<br>        .p2align 4,,15<br>        .globl  facttail<br>        .type   facttail, @function<br>facttail:<br>.LFB8:<br>        .cfi_startproc<br>        .p2align 4,,10<br>        .p2align 3<br>.L4:<br>        jmp     .L4<br>        .cfi_endproc<br>.LFE8:<br>        .size   facttail, .-facttail<br>        .ident  “GCC: (GNU) 4.8.2”<br>        .section        .note.GNU-stack,””,@progbits<br></pre><br>卧槽，我完全看不懂了，不过估计这东西优化成为了一个循环，看.L4，不过这个怎么把递归也搞成循环了？！这个真心不懂，求大家指教</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-1966-e5-b9-b4-e5-9b-be-e7-81-b5-e5-a5-96-e8-89-be-e4-bc-a6-c2-b7-e4-bd-a9-e5-88-a9-ef-bc-88alan-j-perlis-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/02/12/1966-e5-b9-b4-e5-9b-be-e7-81-b5-e5-a5-96-e8-89-be-e4-bc-a6-c2-b7-e4-bd-a9-e5-88-a9-ef-bc-88alan-j-perlis-ef-bc-89/" class="article-date">
  	<time datetime="2014-02-12T05:16:27.000Z" itemprop="datePublished">2014-02-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/12/1966-e5-b9-b4-e5-9b-be-e7-81-b5-e5-a5-96-e8-89-be-e4-bc-a6-c2-b7-e4-bd-a9-e5-88-a9-ef-bc-88alan-j-perlis-ef-bc-89/">1966年图灵奖——艾伦·佩利（Alan J. Perlis）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>艾伦·杰·佩利</strong><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">（</span><strong><span>Alan Jay Perlis</span></strong><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">，1922年4月1日－1990年2月7日），生于美国</span><a href="http://zh.wikipedia.org/wiki/%E5%AE%BE%E5%A4%95%E6%B3%95%E5%B0%BC%E4%BA%9A%E5%B7%9E" target="_blank" rel="external">宾夕法尼亚州</a><a href="http://zh.wikipedia.org/wiki/%E5%8C%B9%E5%85%B9%E5%A0%A1" target="_blank" rel="external">匹兹堡</a><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">，是</span><a href="http://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD" target="_blank" rel="external">美国</a><a href="http://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="external">计算机</a><a href="http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">程序设计</a><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">领域的</span><a href="http://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E5%AE%B6" target="_blank" rel="external">科学</a><a href="http://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E5%AE%B6" target="_blank" rel="external">家</a><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">，首届</span><a href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96" target="_blank" rel="external">图灵奖</a><span style="font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;">的获得者。</span> </p>
<pre><code><span class="xml"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"font-family:sans-serif;font-size:15px;line-height:22.066667556762695px;background-color:#FFFFFF;"</span>&gt;</span></span>![](http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/02/Alan-Perlis.jpg) <span class="xml"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span> 

Alan Perlis获得图灵奖的颁奖词如下：

由于其在[<span class="link_label">高级程序设计</span>](<span class="link_url">http://zh.wikipedia.org/w/index.php?title=%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&amp;amp;action=edit&amp;amp;redlink=1 "%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&amp;amp;action=edit&amp;amp;redlink=1"</span>)技术和[<span class="link_label">编译器</span>](<span class="link_url">http://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8</span>)构造方面的影响。

（<span class="emphasis">_for his influence in the area of advanced programming techniques and compiler construction_</span>）

从获奖词我们看出Alan Perlis最大的贡献就是他的ALGOL语言了。

<span class="emphasis">_下面内容转载自《[程序员](http://www.programmer.com.cn/4752/#more-4752)》。_</span> 

当我们提起高级语言的先驱，首先想到的总是Dennis Ritchie、Bjarne Stroustrup这些主流语言的设计者，似乎很少会提到Alan Perlis这个名字。但Alan Perlis主持设计的ALGOL，趋势C/C++等语言的鼻祖。

Alan Perlis 1922年出生于美国匹兹堡犹太家庭。21岁时，他获得了卡内基理工学院的化学学士学位，这个学院后来发展为现在美国计算机专业排名第一的卡内基梅隆大学。时逢二战，他弃笔从戎。服役期间，他突然对数学产生了强烈兴趣，并在1950年， 从麻省理工学院获得了数学博士学位。两年后他来到普渡大学，出任普渡大学计算中心首任主任，并将IBM CPC计算机引入了普渡，还为其设计了一个叫作IT（Internal Translator）的编程语言。四年之后，他又一跃当上了卡内基理工学院第一任计算机科学系主任，在卡耐基引入了IBM 650，并将IT语言移植到650上。这些使他在程序语言的设计方面，有了许多经验和体会。当ACM成立程序设计语言委员会时，Perlis坐上了主席的位置。

1958年5月27日，瑞士苏黎世召开了一场8个人的讨论会。这个会议并不隆重。ACM的4名代表和德国应用数学和力学学会（GAMM）的4名代表，索性把地点和双方名称连起来，叫苏黎世ACM-GAMM会议。这场会议的组织者，就是Alan Perlis。他们将要在此讨论并规划一种新型的编程语言，叫作国际代数语言（IAL）。

世界上第一个高级语言Fortran存在一些严重的缺陷。比如说它专门为IBM 704设计的，要依赖特定的机器型号工作，很难向其他机器移植等等。IAL的专家们力求设计一种更好的高级语言。在讨论过程中，Perlis认为 “IAL”这个词很绕口，于是将它改名叫作ALGOL。会议结束后，他们成立了一个工作组，根据讨论的结果，开发ALGOL的编译器。1958年年底，第一套编译器诞生了，按照年份命名为ALGOL 58。1960年，Alan Perlis总结了一些经验之后，再次召集参与ALGOL工作的计算机科学家们在巴黎进行了另一场研讨。这场会议的结果，就是后来的ALGOL 60。

1960年夏天，Dijkstra开发了第一个ALGOL 60的编译器，于是ALGOL系列语言正式登上了计算机科学的舞台。随后，Alan Perlis将它引入了大学的课堂。这是Alan Perlis的另一个重要贡献，因为在那个时代，计算机科学混沌初开，程序设计都只是数值分析的一部分。经过Alan Perlis的努力，人们终于看到计算机科学应该是什么样子。Dijkstra后来说，这是一个伟大的标志，可以说直到这个时候，计算机科学才真正地诞生了。而在接下来的30年里，ALGOL一直是教学和学术界用来描述算法的不二之选。它体现出的许多概念，都被后来的编程语言沿用。包括C、C++和 Pascal在内许多主流语言，都因为继承了ALGOL的许多概念，而被称为“类ALGOL语言”。

Alan Perlis因领导了ALGOL的设计工作，并在早期计算机教育中做出了重要贡献，在1962年当选为美国计算机学会的主席，并在四年后，因为他对高级编程技术及其编译器构造的影响成为历史上首位图灵奖得主。五年后，他跳槽到耶鲁大学，连任多年计算机科学系主任，1977年当选美国工程院院士。1982 年，退休后的Alan Perlis返老还童，写下了名文“Epigrams on Programming”，发表在ACM的SIGPLAN期刊上。其中包含130条编程箴言，可能是被引用最广泛的计算机文章之一。在发表在ACM的 SIGPLAN期刊上，他写下了一系列关于编程的幽默：“如果你给别人讲解程序时，看到对方点头了，那你就拍他一下，他肯定睡觉了。”

Alan Perlis为名著《[<span class="link_label">计算机程序的构造和解释</span>](<span class="link_url">http://www.amazon.cn/mn/detailApp/ref=as_li_qf_sp_asin_tl?_encoding=UTF8&amp;amp;tag=vastwork-23&amp;amp;linkCode=as2&amp;amp;asin=B0011AP7RY&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0011AP7RY</span>)》所写的序中写道，<span class="strong">**如果说艺术解释了我们的梦想，那么计算机就是以程序的名义执行着它们。**</span>计算机科学中特别重要的一点是保持趣味性，不要局限于眼前，应该不断寻找新方向，扩展计算机的能力。这些话今天听来，依然发人深省。

1990年2月7日，Alan Perlis因心脏病在纽哈芬去世，享年68岁。

<span class="emphasis">_下面内容是Alan Perlis的《Epigrams On Programming》_</span> 

<span class="xml"><span class="comment">&lt;!--more--&gt;</span></span>
</code></pre><h1 id=""> </h1><pre><code>Epigrams <span class="function_start"><span class="keyword">on</span></span> Programming
</code></pre><h2 id="-1"> </h2><pre><code><span class="title">Alan</span> J. Perlis
</code></pre><h3 id="-2"> </h3><pre><code><span class="title">Yale</span> University
</code></pre><p><em>This text has been published in SIGPLAN Notices Vol. 17, No. 9, September 1982, pages 7 - 13. I’m offering it here online until ACM stops me.</em><span style="color:#000080;font-family:Simsun;font-size:medium;line-height:normal;background-color:#FFFFFF;"></span> </p>
<pre><code>The phenomena surrounding computers are diverse <span class="keyword">and</span> yield a surprisingly rich base <span class="keyword">for</span> launching metaphors <span class="keyword">at</span> individual <span class="keyword">and</span> group activities. Conversely, classical human endeavors provide an inexhaustible source <span class="keyword">of</span> metaphor <span class="keyword">for</span> those <span class="keyword">of</span> us who are <span class="keyword">in</span> labor within computation. Such relationships <span class="keyword">between</span> society <span class="keyword">and</span> device are <span class="keyword">not</span> new, <span class="keyword">but</span> <span class="keyword">the</span> incredible growth <span class="keyword">of</span> <span class="keyword">the</span> computer's influence (both <span class="type">real</span> <span class="keyword">and</span> implied) lends this symbiotic dependency a vitality like a gangly youth growing <span class="keyword">out of</span> his clothes within an endless puberty.

The epigrams <span class="keyword">that</span> follow attempt <span class="keyword">to</span> capture <span class="keyword">some</span> <span class="keyword">of</span> <span class="keyword">the</span> dimensions <span class="keyword">of</span> this traffic <span class="keyword">in</span> imagery <span class="keyword">that</span> sharpens, focuses, clarifies, enlarges <span class="keyword">and</span> beclouds our view <span class="keyword">of</span> this most remarkable <span class="keyword">of</span> all mans' artifacts, <span class="keyword">the</span> computer.
</code></pre><ol>
<li>One man’s constant is another man’s variable.<span style="background-color:#FF9900;color:#000000;">（一个人的常量是别人的变量）</span> </li>
<li>Functions delay binding: data structures induce binding. Moral: Structure data late in the programming process.<span style="font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（这个翻译不来==）</span> </li>
<li>Syntactic sugar causes cancer of the semicolons.<span style="font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（糖衣语法容易引起分号的问题？）</span> </li>
<li>Every program is a part of some other program and rarely fits.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（每一段程序都是另外一段程序的一部分，但总有差别？）</span></li>
<li>If a program manipulates a large amount of data, it does so in a small number of ways.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（一段程序只有使用很少的方法操纵了一大堆的数据？）</span></li>
<li>Symmetry is a complexity reducing concept (co-routines include sub-routines); seek it everywhere.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（追求对称性是一种降低复杂度的方法（和子函数合作），我们要不断的去追求）</span></li>
<li>It is easier to write an incorrect program than understand a correct one.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（写一段错误的程序比理解一段正确的程序容易）</span></li>
<li>A programming language is low level when its programs require attention to the irrelevant.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（如果一种程序语言关注一些不相关的东西，那么它就是低级的）</span></li>
<li>It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（使用100个函数操作一个数据结构比使用是个函数操作10个数据结构好）</span></li>
<li>Get into a rut early: Do the same processes the same way. Accumulate idioms. Standardize. The only difference (!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（开始积累：使用同样的方法做同样的事，积累常用方法和标准。你和莎士比亚的区别不是在于单词量上的差距，而是在于习语上）</span></li>
<li>If you have a procedure with 10 parameters, you probably missed some.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（如果你需要处理十个参数，你最好忽略掉其中一些）</span></li>
<li>Recursion is the root of computation since it trades description for time.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（递归是计算的根本，应为它更加容易表示清楚，虽然花了更多的时间）</span></li>
<li>If two people write exactly the same program, each should be put in micro-code and then they certainly won’t be the same.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（如果两个人写了完全一样的程序，那么把程序放缩到微代码级别，他们的程序一定是不一样的）</span></li>
<li>In the long run every program becomes rococo - then rubble.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（每个程序长时间运行都会变的很渣）</span></li>
<li>Everything should be built top-down, except the first time.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（每次应该从顶至下的构造，除了第一次）</span></li>
<li>Every program has (at least) two purposes: the one for which it was written and another for which it wasn’t.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（每次写程序都有2个目标：一个是写你想要的功能，另一个是写你不想要的功能）</span></li>
<li>If a listener nods his head when you’re explaining your program, wake him up.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（你向别人讲你的程序，如果他点头了，那么他一定是睡着了）</span></li>
<li>A program without a loop and a structured variable isn’t worth writing.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（一个没有循环和结构化变量的程序是不值得写的）</span></li>
<li>A language that doesn’t affect the way you think about programming, is not worth knowing.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（一个不能影响你思考程序的编程语言是不值得去学习的）</span></li>
<li>Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（只有有模块化，那就有误解的可能，隐藏信息基本上都意味着需要交流）</span></li>
<li>Optimization hinders evolution.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（优化阻碍发展）</span></li>
<li>A good system can’t have a weak command language.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（好的系统一定有个强大的控制语言）</span></li>
<li>To understand a program you must become both the machine and the program.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（理解一个程序的最佳方式就是把你自己变成机器和程序）</span></li>
<li>Perhaps if we wrote programs from childhood on, as adults we’d be able to read them.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（如果我们从小就开始写程序，那么当我们成年的时候我们就有能力去读他们了）</span></li>
<li>One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（人只能在脑中展现复杂的信息。就像是远闻不如一见）</span></li>
<li>There will always be things we wish to say in our programs that in all known languages can only be said poorly.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（总是会出现这样的事儿：每个人都认为自己的程序是最好）</span></li>
<li>Once you understand how to write a program get someone else to write it.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（一旦你某一天理解了如何去写程序，就叫另外一个人去写）</span></li>
<li>Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（计算机里很难去找到正确的单位时间去丈量进步）</span></li>
<li>For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（对于一个系统，模拟一个侧面就是在控制图中增加一个边创造一个循环，而不是仅仅增加一个节点）</span></li>
<li>In programming, everything we do is a special case of something more general - and often we know it too quickly.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（在写程序里，我们做的大多数都是一般情况中的个例，我们经常知道的太快了）</span></li>
<li>Simplicity does not precede complexity, but follows it.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（简单的方法不意味着领先复杂的方法，但是还是要做用简单的方法）</span></li>
<li>Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（程序猿的评估方法不是他们的天赋和逻辑，是他们分析问题的完整程度）</span></li>
<li>The 11th commandment was “Thou Shalt Compute” or “Thou Shalt Not Compute” - I forget which.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（我不记得第十一诫里应该是“你应该计算”还是“你不该计算”）</span></li>
<li>The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（字符串是一种很爽的数据结构，无论什么时候都是通过复制操作进行传送的，这简直是隐藏信息的良器）</span></li>
<li>Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（你可以教任何人雕刻：但是对米开朗基罗来说，他应该被教那些事儿不能去做，这对于好的程序员也是一样的）</span></li>
<li>The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.<span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">（</span><span style="color:#000080;font-family:Simsun;font-size:medium;line-height:24px;background-color:#FF9900;">）</span></li>
<li>The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standardization of real computers would be a disaster - and so it probably won’t happen.</li>
<li>Structured Programming supports the law of the excluded muddle.</li>
<li>Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.</li>
<li>There are two ways to write error-free programs; only the third one works.</li>
<li>Some programming languages manage to absorb change, but withstand progress.</li>
<li>You can measure a programmer’s perspective by noting his attitude on the continuing vitality of FORTRAN.</li>
<li>In software systems it is often the early bird that makes the worm.</li>
<li>Sometimes I think the only universal in the computing field is the fetch-execute-cycle.</li>
<li>The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.</li>
<li>Like punning, programming is a play on words.</li>
<li>As Will Rogers would have said, “There is no such thing as a free variable.”</li>
<li>The best book on programming for the layman is “Alice in Wonderland”; but that’s because it’s the best book on anything for the layman.</li>
<li>Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.</li>
<li>When we understand knowledge-based systems, it will be as before - except our finger-tips will have been singed.</li>
<li>Bringing computers into the home won’t change either one, but may revitalize the corner saloon.</li>
<li>Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we’re always starting over.</li>
<li>So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.</li>
<li>Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</li>
<li>A LISP programmer knows the value of everything, but the cost of nothing.</li>
<li>Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.</li>
<li>It is easier to change the specification to fit the program than vice versa.</li>
<li>Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.</li>
<li>In English every word can be verbed. Would that it were so in our programming languages.</li>
<li>Dana Scott is the Church of the Lattice-Way Saints.</li>
<li>In programming, as in everything else, to be in error is to be reborn.</li>
<li>In computing, invariants are ephemeral.</li>
<li>When we write programs that “learn”, it turns out we do and they don’t.</li>
<li>Often it is means that justify ends: Goals advance technique and technique survives even when goal structures crumble.</li>
<li>Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.</li>
<li>Making something variable is easy. Controlling duration of constancy is the trick.</li>
<li>Think of all the psychic energy expended in seeking a fundamental distinction between “algorithm” and “program”.</li>
<li>If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?</li>
<li>In a 5 year period we get one superb programming language. Only we can’t control when the 5 year period will begin.</li>
<li>Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn’t require them to carry a blackboard on their ponies.</li>
<li>Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.</li>
<li>An adequate bootstrap is a contradiction in terms.</li>
<li>It is not a language’s weaknesses but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.</li>
<li>It is possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as soap bubble?</li>
<li>Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.</li>
<li>It is the user who should parameterize procedures, not their creators.</li>
<li>The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.</li>
<li>If your computer speaks English it was probably made in Japan.</li>
<li>A year spent in artificial intelligence is enough to make one believe in God.</li>
<li>Prolonged contact with the computer turns mathematicians into clerks and vice versa.</li>
<li>In computing, turning the obvious into the useful is a living definition of the word “frustration”.</li>
<li>We are on the verge: Today our program proved Fermat’s next-to-last theorem!</li>
<li>What is the difference between a Turing machine and the modern computer? It’s the same as that between Hillary’s ascent of Everest and the establishment of a Hilton hotel on its peak.</li>
<li>Motto for a research laboratory: What we work on today, others will first think of tomorrow.</li>
<li>Though the Chinese should adore APL, it’s FORTRAN they put their money on.</li>
<li>We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.</li>
<li>We have the mini and the micro computer. In what semantic niche would the pico computer fall?</li>
<li>It is not the computer’s fault that Maxwell’s equations are not adequate to design the electric motor.</li>
<li>One does not learn computing by using a hand calculator, but one can forget arithmetic.</li>
<li>Computation has made the tree flower.</li>
<li>The computer reminds one of Lon Chaney - it is the machine of a thousand faces.</li>
<li>The computer is the ultimate polluter. Its feces are indistinguishable from the food it produces.</li>
<li>When someone says “I want a programming language in which I need only say what I wish done,” give him a lollipop.</li>
<li>Interfaces keep things tidy, but don’t accelerate growth: Functions do.</li>
<li>Don’t have good ideas if you aren’t willing to be responsible for them.</li>
<li>Computers don’t introduce order anywhere as much as they expose opportunities.</li>
<li>When a professor insists computer science is X but not Y, have compassion for his graduate students.</li>
<li>In computing, the mean time to failure keeps getting shorter.</li>
<li>In man-machine symbiosis, it is man who must adjust: The machines can’t.</li>
<li>We will never run out of things to program as long as there is a single program around.</li>
<li>Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You’ve solved the wrong problem. Work hard to improve.</li>
<li>One can’t proceed from the informal to the formal by formal means.</li>
<li>Purely applicative languages are poorly applicable.</li>
<li>The proof of a system’s value is its existence.</li>
<li>You can’t communicate complexity, only an awareness of it.</li>
<li>It’s difficult to extract sense from strings, but they’re the only communication coin we can count on.</li>
<li>The debate rages on: Is PL/I Bactrian or Dromedary?</li>
<li>Whenever two programmers meet to criticize their programs, both are silent.</li>
<li>Think of it! With VLSI we can pack 100 ENIACs in 1 sq.cm.</li>
<li>Editing is a rewording activity.</li>
<li>Why did the Roman Empire collapse? What is the Latin for office automation?</li>
<li>Computer Science is embarrassed by the computer.</li>
<li>The only constructive theory connecting neuroscience and psychology will arise from the study of software.</li>
<li>Within a computer natural language is unnatural.</li>
<li>Most people find the concept of programming obvious, but the doing impossible.</li>
<li>You think you know when you learn, are more sure when you can write, even more when you can teach, but certain when you can program.</li>
<li>It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?</li>
<li>If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.</li>
<li>Programming is an unnatural act.</li>
<li>Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.</li>
<li><p>In seeking the unattainable, simplicity only gets in the way.</p>
<pre><code><span class="label">If</span> there are epigrams, there must <span class="keyword">be </span>meta-epigrams.
</code></pre></li>
<li><p>Epigrams are interfaces across which appreciation and insight flow.</p>
</li>
<li>Epigrams parameterize auras.</li>
<li>Epigrams are macros, since they are executed at read time.</li>
<li>Epigrams crystallize incongruities.</li>
<li>Epigrams retrieve deep semantics from a data base that is all procedure.</li>
<li>Epigrams scorn detail and make a point: They are a superb high-level documentation.</li>
<li>Epigrams are more like vitamins than protein.</li>
<li>Epigrams have extremely low entropy.</li>
<li>The last epigram? Neither eat nor drink them, snuff epigrams.</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/图灵奖/">图灵奖</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-linux-e6-9f-a5-e6-89-be-e5-b9-b6-e6-9b-bf-e6-8d-a2-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e6-8c-87-e5-ae-9a-e5-86-85-e5-ae-b9" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/01/20/linux-e6-9f-a5-e6-89-be-e5-b9-b6-e6-9b-bf-e6-8d-a2-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e6-8c-87-e5-ae-9a-e5-86-85-e5-ae-b9/" class="article-date">
  	<time datetime="2014-01-20T08:35:57.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/linux-e6-9f-a5-e6-89-be-e5-b9-b6-e6-9b-bf-e6-8d-a2-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e6-8c-87-e5-ae-9a-e5-86-85-e5-ae-b9/">linux 查找并替换文件中的指定内容</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="起因">起因</h3><p>在我刚刚把nginx搬到QTCreator的时候，由于nginx源码都是使用#include &lt;xx.h&gt;的形式，原先我并没有把nginx的头文件放在系统库头文件的变量中，于是乎，我脑抽般的想起，我把&lt;&gt;替换成“”的形式，这样就可以方便的运行了，当然，这个我想的太理想了，略2，但是还是让我学习到了如何查找并替换文件中的特定内容。</p>
<h3 id="相关命令">相关命令</h3><p>我使用了这样的命令</p>
<p>&lt;pre  lang=”shell”&gt;</p>
<p>find -name “<em>.c” | xargs sed -i ‘s/&lt;([a-z|A-Z|_|0-9]</em>.h)&gt;/“\1”/g’</p>
<p>&lt;/pre&gt;</p>
<p>现在来详细解释一下，find命令是用来查找文件的</p>
<p>详细可参见<a href="http://www.cnblogs.com/wanqieddy/archive/2011/06/09/2076785.html" target="_blank" rel="external">find 用法实例</a></p>
<p>xargs这个是给命令传递参数的一个过滤器，是传递内容的，</p>
<p>详细可参见<a href="http://www.cnblogs.com/wdpp/archive/2012/02/28/2386683.html" target="_blank" rel="external">xargs命令</a></p>
<p>sed这个命令可以参见<a href="http://www.iteye.com/topic/587673" target="_blank" rel="external">sed命令</a></p>
<p>我解释一下我的用法，因为我是要替换“#include &lt;xx.h&gt;”中的&lt;&gt;成为””，所以使用</p>
<p>&lt;pre lang=”shell”&gt;</p>
<p>sed -i ‘s/&lt;([a-z|A-Z|_|0-9]*.h)&gt;/“\1”/g’</p>
<p>&lt;/pre&gt;</p>
<p>-i的意思是把改变了的内容要回写进文件</p>
<p>至于后面一句是sed用来匹配替换文本，</p>
<p>s表示替换的意思</p>
<p>&lt;([a-z|A-Z|<em>|0-9]*.h)&gt;是我们的&lt;xx.h&gt;因为xx.h是变化的，所以我们使用正则表达式([a-z|A-Z|</em>|0-9]*.h)来准确的获取，但是我们要对（）进行转义</p>
<p>“\1”:这里\1的意思就是正则表达式([a-z|A-Z|_|0-9]*.h)匹配上的第一个的字符串的值，同理\2就是匹配上的第二个字符串的值，它是一个变量。这样子我们就实现了这种替换。</p>
<p>&nbsp;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e4-bd-bf-e7-94-a8qt-creator-e6-9f-a5-e7-9c-8b-e5-b9-b6-e8-b0-83-e8-af-95nginx-e6-ba-90-e7-a0-81" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/01/20/e4-bd-bf-e7-94-a8qt-creator-e6-9f-a5-e7-9c-8b-e5-b9-b6-e8-b0-83-e8-af-95nginx-e6-ba-90-e7-a0-81/" class="article-date">
  	<time datetime="2014-01-20T07:33:43.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/e4-bd-bf-e7-94-a8qt-creator-e6-9f-a5-e7-9c-8b-e5-b9-b6-e8-b0-83-e8-af-95nginx-e6-ba-90-e7-a0-81/">使用QT Creator查看并调试nginx源码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-前言">1.前言</h2><p>由于原先以前被vs2008以及eclipse宠坏了，vi使用又不熟悉，本来想好好学习nginx源码的我很是拙计，我亟需一个IDE来阅读以及调试源代码，于是我看上了QtCreator，，于是本博文就是介绍如何把nginx源码搞成qt creator工程。</p>
<h2 id="2-建立-pro文件">2.建立.pro文件</h2><p></p><p>我们要先学习一下QT Creator的工程文件.pro，因为QTCreator的qmake按照.pro文件生成Makefile的。</p>
<p>现在我们先来看看我们需要用到的.pro配置项</p>
<p>配置项的格式是：key = value</p>
<p>我们需要的key如下</p>
<p>我把我的.pro文件贴出来</p>
<pre lang="xml">
TARGET = nginx
DESTDIR = ./objs
LIBS = -lpthread -lcrypt -lpcre -lcrypto -lcrypto -lz
INCLUDEPATH += \
        src/core \
        src/event \
        src/event/modules \
        src/os/unix \
        src/http/modules \
        src/http \
        objs
HEADERS = src/core/nginx.h \
        src/core/ngx_config.h \
        src/core/ngx_core.h \
        src/core/ngx_log.h \
        src/core/ngx_palloc.h \
        src/core/ngx_array.h \
        src/core/ngx_list.h \
        src/core/ngx_hash.h \
        src/core/ngx_buf.h \
        src/core/ngx_queue.h \
        src/core/ngx_string.h \
        src/core/ngx_parse.h \
        src/core/ngx_inet.h \
        src/core/ngx_file.h \
        src/core/ngx_crc.h \
        src/core/ngx_crc32.h \
        src/core/ngx_murmurhash.h \
        src/core/ngx_md5.h \
        src/core/ngx_sha1.h \
        src/core/ngx_rbtree.h \
        src/core/ngx_radix_tree.h \
        src/core/ngx_slab.h \
        src/core/ngx_times.h \
        src/core/ngx_shmtx.h \
        src/core/ngx_connection.h \
        src/core/ngx_cycle.h \
        src/core/ngx_conf_file.h \
        src/core/ngx_resolver.h \
        src/core/ngx_open_file_cache.h \
        src/core/ngx_crypt.h \
        src/event/ngx_event.h \
        src/event/ngx_event_timer.h \
        src/event/ngx_event_posted.h \
        src/event/ngx_event_busy_lock.h \
        src/event/ngx_event_connect.h \
        src/event/ngx_event_pipe.h \
        src/os/unix/ngx_time.h \
        src/os/unix/ngx_errno.h \
        src/os/unix/ngx_alloc.h \
        src/os/unix/ngx_files.h \
        src/os/unix/ngx_channel.h \
        src/os/unix/ngx_shmem.h \
        src/os/unix/ngx_process.h \
        src/os/unix/ngx_setaffinity.h \
        src/os/unix/ngx_setproctitle.h \
        src/os/unix/ngx_atomic.h \
        src/os/unix/ngx_gcc_atomic_x86.h \
        src/os/unix/ngx_thread.h \
        src/os/unix/ngx_socket.h \
        src/os/unix/ngx_os.h \
        src/os/unix/ngx_user.h \
        src/os/unix/ngx_process_cycle.h \
        src/os/unix/ngx_linux_config.h \
        src/os/unix/ngx_linux.h \
        src/core/ngx_regex.h \
        objs/ngx_auto_config.h \
        src/http/ngx_http.h \
        src/http/ngx_http_request.h \
        src/http/ngx_http_config.h \
        src/http/ngx_http_core_module.h \
        src/http/ngx_http_cache.h \
        src/http/ngx_http_variables.h \
        src/http/ngx_http_script.h \
        src/http/ngx_http_upstream.h \
        src/http/ngx_http_upstream_round_robin.h \
        src/http/ngx_http_busy_lock.h \
        src/http/modules/ngx_http_ssi_filter_module.h
SOURCES = src/core/nginx.c \
        src/core/ngx_log.c \
        src/core/ngx_palloc.c \
        src/core/ngx_array.c \
        src/core/ngx_list.c \
        src/core/ngx_hash.c \
        src/core/ngx_buf.c \
        src/core/ngx_queue.c \
        src/core/ngx_output_chain.c \
        src/core/ngx_string.c \
        src/core/ngx_parse.c \
        src/core/ngx_inet.c \
        src/core/ngx_file.c \
        src/core/ngx_crc32.c \
        src/core/ngx_murmurhash.c \
        src/core/ngx_md5.c \
        src/core/ngx_rbtree.c \
        src/core/ngx_radix_tree.c \
        src/core/ngx_slab.c \
        src/core/ngx_times.c \
        src/core/ngx_shmtx.c \
        src/core/ngx_connection.c \
        src/core/ngx_cycle.c \
        src/core/ngx_spinlock.c \
        src/core/ngx_cpuinfo.c \
        src/core/ngx_conf_file.c \
        src/core/ngx_resolver.c \
        src/core/ngx_open_file_cache.c \
        src/core/ngx_crypt.c \
        src/event/ngx_event.c \
        src/event/ngx_event_timer.c \
        src/event/ngx_event_posted.c \
        src/event/ngx_event_busy_lock.c \
        src/event/ngx_event_accept.c \
        src/event/ngx_event_connect.c \
        src/event/ngx_event_pipe.c \
        src/os/unix/ngx_time.c \
        src/os/unix/ngx_errno.c \
        src/os/unix/ngx_alloc.c \
        src/os/unix/ngx_files.c \
        src/os/unix/ngx_socket.c \
        src/os/unix/ngx_recv.c \
        src/os/unix/ngx_readv_chain.c \
        src/os/unix/ngx_udp_recv.c \
        src/os/unix/ngx_send.c \
        src/os/unix/ngx_writev_chain.c \
        src/os/unix/ngx_channel.c \
        src/os/unix/ngx_shmem.c \
        src/os/unix/ngx_process.c \
        src/os/unix/ngx_daemon.c \
        src/os/unix/ngx_setaffinity.c \
        src/os/unix/ngx_setproctitle.c \
        src/os/unix/ngx_posix_init.c \
        src/os/unix/ngx_user.c \
        src/os/unix/ngx_process_cycle.c \
        src/os/unix/ngx_linux_init.c \
        src/event/modules/ngx_epoll_module.c \
        src/os/unix/ngx_linux_sendfile_chain.c \
        src/core/ngx_regex.c \
        src/http/ngx_http.c \
        src/http/ngx_http_core_module.c \
        src/http/ngx_http_special_response.c \
        src/http/ngx_http_request.c \
        src/http/ngx_http_parse.c \
        src/http/ngx_http_header_filter_module.c \
        src/http/ngx_http_write_filter_module.c \
        src/http/ngx_http_copy_filter_module.c \
        src/http/modules/ngx_http_log_module.c \
        src/http/ngx_http_request_body.c \
        src/http/ngx_http_variables.c \
        src/http/ngx_http_script.c \
        src/http/ngx_http_upstream.c \
        src/http/ngx_http_upstream_round_robin.c \
        src/http/ngx_http_parse_time.c \
        src/http/modules/ngx_http_static_module.c \
        src/http/modules/ngx_http_index_module.c \
        src/http/modules/ngx_http_chunked_filter_module.c \
        src/http/modules/ngx_http_range_filter_module.c \
        src/http/modules/ngx_http_headers_filter_module.c \
        src/http/modules/ngx_http_not_modified_filter_module.c \
        src/http/ngx_http_busy_lock.c \
        src/http/ngx_http_file_cache.c \
        src/http/modules/ngx_http_gzip_filter_module.c \
        src/http/ngx_http_postpone_filter_module.c \
        src/http/modules/ngx_http_ssi_filter_module.c \
        src/http/modules/ngx_http_charset_filter_module.c \
        src/http/modules/ngx_http_userid_filter_module.c \
        src/http/modules/ngx_http_autoindex_module.c \
        src/http/modules/ngx_http_auth_basic_module.c \
        src/http/modules/ngx_http_access_module.c \
        src/http/modules/ngx_http_limit_conn_module.c \
        src/http/modules/ngx_http_limit_req_module.c \
        src/http/modules/ngx_http_geo_module.c \
        src/http/modules/ngx_http_map_module.c \
        src/http/modules/ngx_http_split_clients_module.c \
        src/http/modules/ngx_http_referer_module.c \
        src/http/modules/ngx_http_rewrite_module.c \
        src/http/modules/ngx_http_proxy_module.c \
        src/http/modules/ngx_http_fastcgi_module.c \
        src/http/modules/ngx_http_uwsgi_module.c \
        src/http/modules/ngx_http_scgi_module.c \
        src/http/modules/ngx_http_memcached_module.c \
        src/http/modules/ngx_http_empty_gif_module.c \
        src/http/modules/ngx_http_browser_module.c \
        src/http/modules/ngx_http_upstream_ip_hash_module.c \
        src/http/modules/ngx_http_upstream_least_conn_module.c \
        src/http/modules/ngx_http_upstream_keepalive_module.c \
        objs/ngx_modules.c
</pre>

<h2 id="3-nginx的编译配置生成">3.nginx的编译配置生成</h2><p></p><p>由于nginx有很多的模块，在编译的过程中，nginx会根据系统环境的设置，生成ngx_modules.c、ngx_auto_config.h、ngx_auto_headers.h、Makefile等，然后，源代码中根据这些配置头文件，使用宏定义进行差异化编译。所以我们最重要的一步就是根据系统环境生成ngx_modules.c、ngx_auto_config.h、ngx_auto_headers.h、Makefile这几个文件。</p>
<p>步骤就是非常简单的，使用./configure就好了，以上文件都生成在nginx目录下的objs文件夹内。</p>
<h2 id="生成QTCreator版本的nginx">生成QTCreator版本的nginx</h2><p>打开QTCreator创建一个空的QTCreator项目,如下</p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/creat.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/creat.jpg" alt="" title="creat"></a></p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create2.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create2.jpg" alt="" title="create2"></a></p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create3.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create3.jpg" alt="" title="create3"></a></p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create4.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/create4.jpg" alt="" title="create4"></a></p>
<p>现在把nginx文件夹下的src、objs文件夹拷贝到nginx目录下</p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/pro.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/pro.jpg" alt="" title="pro"></a></p>
<p>修改.pro文件</p>
<pre lang="xml">
TARGET = nginx
DESTDIR = ./objs
LIBS = -lpthread -lcrypt -lpcre -lcrypto -lcrypto -lz
INCLUDEPATH += \
        src/core \
        src/event \
        src/event/modules \
        src/os/unix \
        src/http/modules \
        src/http \
        objs
HEADERS = src/core/nginx.h \
        src/core/ngx_config.h \
        src/core/ngx_core.h \
        src/core/ngx_log.h \
        src/core/ngx_palloc.h \
        src/core/ngx_array.h \
        src/core/ngx_list.h \
        src/core/ngx_hash.h \
        src/core/ngx_buf.h \
        src/core/ngx_queue.h \
        src/core/ngx_string.h \
        src/core/ngx_parse.h \
        src/core/ngx_inet.h \
        src/core/ngx_file.h \
        src/core/ngx_crc.h \
        src/core/ngx_crc32.h \
        src/core/ngx_murmurhash.h \
        src/core/ngx_md5.h \
        src/core/ngx_sha1.h \
        src/core/ngx_rbtree.h \
        src/core/ngx_radix_tree.h \
        src/core/ngx_slab.h \
        src/core/ngx_times.h \
        src/core/ngx_shmtx.h \
        src/core/ngx_connection.h \
        src/core/ngx_cycle.h \
        src/core/ngx_conf_file.h \
        src/core/ngx_resolver.h \
        src/core/ngx_open_file_cache.h \
        src/core/ngx_crypt.h \
        src/event/ngx_event.h \
        src/event/ngx_event_timer.h \
        src/event/ngx_event_posted.h \
        src/event/ngx_event_busy_lock.h \
        src/event/ngx_event_connect.h \
        src/event/ngx_event_pipe.h \
        src/os/unix/ngx_time.h \
        src/os/unix/ngx_errno.h \
        src/os/unix/ngx_alloc.h \
        src/os/unix/ngx_files.h \
        src/os/unix/ngx_channel.h \
        src/os/unix/ngx_shmem.h \
        src/os/unix/ngx_process.h \
        src/os/unix/ngx_setaffinity.h \
        src/os/unix/ngx_setproctitle.h \
        src/os/unix/ngx_atomic.h \
        src/os/unix/ngx_gcc_atomic_x86.h \
        src/os/unix/ngx_thread.h \
        src/os/unix/ngx_socket.h \
        src/os/unix/ngx_os.h \
        src/os/unix/ngx_user.h \
        src/os/unix/ngx_process_cycle.h \
        src/os/unix/ngx_linux_config.h \
        src/os/unix/ngx_linux.h \
        src/core/ngx_regex.h \
        objs/ngx_auto_config.h \
        src/http/ngx_http.h \
        src/http/ngx_http_request.h \
        src/http/ngx_http_config.h \
        src/http/ngx_http_core_module.h \
        src/http/ngx_http_cache.h \
        src/http/ngx_http_variables.h \
        src/http/ngx_http_script.h \
        src/http/ngx_http_upstream.h \
        src/http/ngx_http_upstream_round_robin.h \
        src/http/ngx_http_busy_lock.h \
        src/http/modules/ngx_http_ssi_filter_module.h
SOURCES = src/core/nginx.c \
        src/core/ngx_log.c \
        src/core/ngx_palloc.c \
        src/core/ngx_array.c \
        src/core/ngx_list.c \
        src/core/ngx_hash.c \
        src/core/ngx_buf.c \
        src/core/ngx_queue.c \
        src/core/ngx_output_chain.c \
        src/core/ngx_string.c \
        src/core/ngx_parse.c \
        src/core/ngx_inet.c \
        src/core/ngx_file.c \
        src/core/ngx_crc32.c \
        src/core/ngx_murmurhash.c \
        src/core/ngx_md5.c \
        src/core/ngx_rbtree.c \
        src/core/ngx_radix_tree.c \
        src/core/ngx_slab.c \
        src/core/ngx_times.c \
        src/core/ngx_shmtx.c \
        src/core/ngx_connection.c \
        src/core/ngx_cycle.c \
        src/core/ngx_spinlock.c \
        src/core/ngx_cpuinfo.c \
        src/core/ngx_conf_file.c \
        src/core/ngx_resolver.c \
        src/core/ngx_open_file_cache.c \
        src/core/ngx_crypt.c \
        src/event/ngx_event.c \
        src/event/ngx_event_timer.c \
        src/event/ngx_event_posted.c \
        src/event/ngx_event_busy_lock.c \
        src/event/ngx_event_accept.c \
        src/event/ngx_event_connect.c \
        src/event/ngx_event_pipe.c \
        src/os/unix/ngx_time.c \
        src/os/unix/ngx_errno.c \
        src/os/unix/ngx_alloc.c \
        src/os/unix/ngx_files.c \
        src/os/unix/ngx_socket.c \
        src/os/unix/ngx_recv.c \
        src/os/unix/ngx_readv_chain.c \
        src/os/unix/ngx_udp_recv.c \
        src/os/unix/ngx_send.c \
        src/os/unix/ngx_writev_chain.c \
        src/os/unix/ngx_channel.c \
        src/os/unix/ngx_shmem.c \
        src/os/unix/ngx_process.c \
        src/os/unix/ngx_daemon.c \
        src/os/unix/ngx_setaffinity.c \
        src/os/unix/ngx_setproctitle.c \
        src/os/unix/ngx_posix_init.c \
        src/os/unix/ngx_user.c \
        src/os/unix/ngx_process_cycle.c \
        src/os/unix/ngx_linux_init.c \
        src/event/modules/ngx_epoll_module.c \
        src/os/unix/ngx_linux_sendfile_chain.c \
        src/core/ngx_regex.c \
        src/http/ngx_http.c \
        src/http/ngx_http_core_module.c \
        src/http/ngx_http_special_response.c \
        src/http/ngx_http_request.c \
        src/http/ngx_http_parse.c \
        src/http/ngx_http_header_filter_module.c \
        src/http/ngx_http_write_filter_module.c \
        src/http/ngx_http_copy_filter_module.c \
        src/http/modules/ngx_http_log_module.c \
        src/http/ngx_http_request_body.c \
        src/http/ngx_http_variables.c \
        src/http/ngx_http_script.c \
        src/http/ngx_http_upstream.c \
        src/http/ngx_http_upstream_round_robin.c \
        src/http/ngx_http_parse_time.c \
        src/http/modules/ngx_http_static_module.c \
        src/http/modules/ngx_http_index_module.c \
        src/http/modules/ngx_http_chunked_filter_module.c \
        src/http/modules/ngx_http_range_filter_module.c \
        src/http/modules/ngx_http_headers_filter_module.c \
        src/http/modules/ngx_http_not_modified_filter_module.c \
        src/http/ngx_http_busy_lock.c \
        src/http/ngx_http_file_cache.c \
        src/http/modules/ngx_http_gzip_filter_module.c \
        src/http/ngx_http_postpone_filter_module.c \
        src/http/modules/ngx_http_ssi_filter_module.c \
        src/http/modules/ngx_http_charset_filter_module.c \
        src/http/modules/ngx_http_userid_filter_module.c \
        src/http/modules/ngx_http_autoindex_module.c \
        src/http/modules/ngx_http_auth_basic_module.c \
        src/http/modules/ngx_http_access_module.c \
        src/http/modules/ngx_http_limit_conn_module.c \
        src/http/modules/ngx_http_limit_req_module.c \
        src/http/modules/ngx_http_geo_module.c \
        src/http/modules/ngx_http_map_module.c \
        src/http/modules/ngx_http_split_clients_module.c \
        src/http/modules/ngx_http_referer_module.c \
        src/http/modules/ngx_http_rewrite_module.c \
        src/http/modules/ngx_http_proxy_module.c \
        src/http/modules/ngx_http_fastcgi_module.c \
        src/http/modules/ngx_http_uwsgi_module.c \
        src/http/modules/ngx_http_scgi_module.c \
        src/http/modules/ngx_http_memcached_module.c \
        src/http/modules/ngx_http_empty_gif_module.c \
        src/http/modules/ngx_http_browser_module.c \
        src/http/modules/ngx_http_upstream_ip_hash_module.c \
        src/http/modules/ngx_http_upstream_least_conn_module.c \
        src/http/modules/ngx_http_upstream_keepalive_module.c \
        objs/ngx_modules.c
</pre>

<p>现在来解释一下为什么这么用</p>
<p>主要解释一下INCLUDEPATH、LIBS，因为我在这上面吃过亏</p>
<p>好了，现在就可以编译了</p>
<p><a href="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/result.jpg" target="_blank" rel="external"><img src="http://zt2peilong-wordpress.stor.sinaapp.com/uploads/2014/01/result.jpg" alt="" title="result"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/nginx/">nginx</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-nginx-e5-a6-82-e4-bd-95-e5-a4-84-e7-90-86-e4-b8-80-e4-b8-aa-e8-af-b7-e6-b1-82" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/01/10/nginx-e5-a6-82-e4-bd-95-e5-a4-84-e7-90-86-e4-b8-80-e4-b8-aa-e8-af-b7-e6-b1-82/" class="article-date">
  	<time datetime="2014-01-10T02:58:52.000Z" itemprop="datePublished">2014-01-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/10/nginx-e5-a6-82-e4-bd-95-e5-a4-84-e7-90-86-e4-b8-80-e4-b8-aa-e8-af-b7-e6-b1-82/">Nginx如何处理一个请求</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>author: Igor Sysoev</strong><br><strong>翻译：赵培龙</strong><br><a href="http://nginx.org/en/docs/http/request_processing.html" target="_blank" rel="external"><strong>原文地址</strong></a></p>
<h1 id="1-基于名字的虚拟服务器">1.基于名字的虚拟服务器</h1><p>nginx第一步就是要决定让哪一个服务器来处理相应的请求。我们使用一个简单的例子来说明：<br>   我们现在配置3个虚拟服务器，都监听80端口，配置文件如下</p>
<pre lang="xml">
server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
</pre>

<p>在这个配置下的nginx，nginx会主动去检查http请求中的host字段，根据host字段的值来判断该把这个请求交给哪一个虚拟服务器来处理。如果没有找到匹配的虚拟服务器名，那么nginx会把这个请求交给默认的虚拟服务器，在上面的配置中，默认的服务器是第一个。当然我们也可以显示的指出(使用default_server)哪一个服务器是默认服务器，</p>
<pre lang="xml">
server {
    listen      80 default_server;
    server_name example.net www.example.net;
    ...
}
</pre>

<div style="backgournd-color:#e7e7e7"><br>在0.8.21的版本之后使用<strong>default_server</strong>,之前的版本都是使用的<strong>defalut</strong><br></div>

<h1 id="2-如何处理一个没有带host值的http请求">2.如何处理一个没有带host值的http请求</h1><p>如果请求头里没有host的值，那么我们在配置中可以这样子定义：</p>
<pre lang="xml">
server {
    listen      80;
    server_name "";
    return      444;
}
</pre>
直接返回444

<div style="backgournd-color:#e7e7e7">
在0.8.48的版本之后，配置中默认的有这种处理方式,但之前的版本都是匹配上的默认服务器
</div>

# 基于IP和主机名的混合虚拟服务器

配置如下
<pre lang="xml">
server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80;
    server_name example.com www.example.com;
    ...
}
</pre>

<p>在这种配置下，nginx首先是匹配请求里面的ip和端口，然后才是匹配头里面的host字段，都没有匹配到的情况下就会送给默认的服务器。</p>
<h1 id="配置一个简单的php站点">配置一个简单的php站点</h1><p>配置如下：</p>
<pre lang="xml">
server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
</pre>

<p>location后面的那些字符串是一个正则表达式，用来匹配URI的，比如location后面的”/“就是来匹配任何请求的，nginx是最长匹配原则来匹配的。</p>
<p>注意到所有的location都没有包含URI的参数，这个是由于URI的参数的写法太多了，举个例子</p>
<pre lang="xml">
/index.php?user=john&page=1
/index.php?page=1&user=john
</pre>

<p>现在我们来看看具体的例子</p>
<p><ol><br>    <li>一个带有”/logo.gif”首先被 location “/“匹配，然后被”.(gif|jpg|png)$”匹配，但是这个是被后面的那个处理，由于root的值是/data/www所以访问的文件的地址是/data/www/logo.gif,nginx会把这个文件发给客户端<br>    </li><li>一个带有”/index.php”依然首先被”/“匹配到，然后被”.(php)$”匹配，这个还是被后面那个location处理。这个请求会传递给fastCGI服务器localhost:9000，fastcgi_param这个配置项是设置FastCGI参数”SCRPT_FILENAME”为”data/www/index.php”,FastCGI服务器会执行这个php脚本，变量$document_root就是root配置项的值，变量$fastcgi_script_name的值就等于请求的URI，这里是”/index.php”<br>   </li><li>一个带有”/about.html”依然会最先被”/“匹配，但是由于没有其他的匹配他，所以就直接被”/“处理了，由于root的值是/data/www，所以nginx会找到/data/www/about.html发给客户端。<br>   </li><li>处理一个请求”/“更加复杂，这个请求首先被location “/“匹配上，然后又被其处理<br>，这个location里面有一个配置项叫做index，这个配置项测试在/data/www（root配置项的值）文件夹下是否有inde.html文件，如果有，则发给客户端，如果没有，若是存在/data/www/index.phph,则重定向到”/index.php”,这个请求又会重新被定向到处理php的location中进行处理，流程和普通的带有”/*.php”一样。</li></ol></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/nginx/">nginx</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 培龙
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>