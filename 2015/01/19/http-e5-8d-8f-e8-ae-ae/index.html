<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>http协议 | Long</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Quick reminder about HTTPWhen haproxy is running in HTTP mode, both the request and the response arefully analyzed and indexed, thus it becomes possible to build matching criteriaon almost anything fo">
<meta property="og:type" content="article">
<meta property="og:title" content="http协议">
<meta property="og:url" content="http://royzhao.github.io/2015/01/19/http-e5-8d-8f-e8-ae-ae/index.html">
<meta property="og:site_name" content="Long">
<meta property="og:description" content="Quick reminder about HTTPWhen haproxy is running in HTTP mode, both the request and the response arefully analyzed and indexed, thus it becomes possible to build matching criteriaon almost anything fo">
<meta property="og:updated_time" content="2015-09-20T12:43:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="http协议">
<meta name="twitter:description" content="Quick reminder about HTTPWhen haproxy is running in HTTP mode, both the request and the response arefully analyzed and indexed, thus it becomes possible to build matching criteriaon almost anything fo">
  
    <link rel="alternative" href="/atom.xml" title="Long" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">培龙</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/storage/" style="font-size: 10px;">-storage</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">骚年，你好</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">培龙</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">培龙</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/royzhao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1837263552/" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/zhao-pei-long-66" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-http-e5-8d-8f-e8-ae-ae" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/19/http-e5-8d-8f-e8-ae-ae/" class="article-date">
  	<time datetime="2015-01-19T04:00:45.000Z" itemprop="datePublished">2015-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      http协议
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a><a class="article-category-link" href="/categories/未分类/杂七杂八/">杂七杂八</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Quick_reminder_about_HTTP">Quick reminder about HTTP</h1><div><br><pre>When haproxy is running in HTTP mode, both the request and the response are<br>fully analyzed and indexed, thus it becomes possible to build matching criteria<br>on almost anything found in the contents.</pre><br><pre>当haproxy运行在HTTP mode的时候，它会把所有的响应以及请求都会分析和建索引，这样才能够让匹配内容中的关键信息成为可能</pre><br><pre>However, it is important to understand how HTTP requests and responses are<br>formed, and how HAProxy decomposes them. It will then become easier to write<br>correct rules and to debug existing configurations.</pre><br><pre>然后，我们需要要理解http的请求和响应的格式记忆haproxy是如何解析他们的，这样我们才能更加正确和简便的写出正确的规则以及调试现有的配置文件</pre><br></div><br><a id="1.1" name="1.1"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.1" target="_blank" rel="external">1.1.</a></small> The HTTP transaction model<br><br><div><br><pre>The HTTP protocol is transaction-driven. This means that each request will lead<br>to one and only one response. Traditionally, a TCP connection is established<br>from the client to the server, a request is sent by the client on the<br>connection, the server responds and the connection is closed. A new request<br>will involve a new connection :<br><br>  [CON1] [REQ1] … [RESP1] [CLO1] [CON2] [REQ2] … [RESP2] [CLO2] …<br><br>In this mode, called the “HTTP close” mode, there are as many connection<br>establishments as there are HTTP transactions. Since the connection is closed<br>by the server after the response, the client does not need to know the content<br>length.</pre><br><pre>http协议时事物驱动的，这意味这每一个请求都会导致有且仅有一个响应。一般来说，一个TCP链接是客户端和服务器之间建立的双向链接，一个客户端的请求在这个链路上被发送，服务器会返回一个响应，然后关闭这个链接，一个请求就会有一个新的链接，就如下一样</pre><br><pre>  [CON1] [REQ1] … [RESP1] [CLO1] [CON2] [REQ2] … [RESP2] [CLO2] …</pre><br><pre>这种模式叫做“HTTP close”模式，当HTTP事物开始的时候会建立很多次的链接。当服务器返回请求后链接被其关闭客户端并不需要知道内容的长度。</pre><br><pre>Due to the transactional nature of the protocol, it was possible to improve it<br>to avoid closing a connection between two subsequent transactions. In this mode<br>however, it is mandatory that the server indicates the content length for each<br>response so that the client does not wait indefinitely. For this, a special<br>header is used: “Content-length”. This mode is called the “keep-alive” mode :<br><br>  [CON] [REQ1] … [RESP1] [REQ2] … [RESP2] [CLO] …</pre><br><pre>根据这种协议的特性，我们可以在两次连续的事物之间避免关闭tcp链接来提升性能。在这种模式下，必须让服务器强制性的设定每个响应的内容长度，这样才能让客户端无限制的等待。为了达到这个目标，一个特殊的头将会被用到“Content-length”。这个模式叫做“keep-alive”模式</pre><br><pre>  [CON] [REQ1] … [RESP1] [REQ2] … [RESP2] [CLO] …</pre><br><pre>Its advantages are a reduced latency between transactions, and less processing<br>power required on the server side. It is generally better than the close mode,<br>but not always because the clients often limit their concurrent connections to<br>a smaller value.</pre><br><pre>keep-alive模式效的减少了两个事物之间的延迟，且可以让服务器提升性能，一般情况下这种模式比close模式好很多，但也不是总是，因为客户端经常会限制并发连接数在一个很小的值上。<br><br>A last improvement in the communications is the pipelining mode. It still uses<br>keep-alive, but the client does not wait for the first response to send the<br>second request. This is useful for fetching large number of images composing a<br>page :<br><br>  [CON] [REQ1] [REQ2] … [RESP1] [RESP2] [CLO] …</pre><br><pre>为了解决这个问题，我们可以使用一种叫做pipelining的模式，它使用了keep-alive，客户端在发送第二个请求的时候就不需要等待第一个请求的响应了。这个在其请求页面上有大量的图片的时候很有用。</pre><br><pre>This can obviously have a tremendous benefit on performance because the network<br>latency is eliminated between subsequent requests. Many HTTP agents do not<br>correctly support pipelining since there is no way to associate a response with<br>the corresponding request in HTTP. For this reason, it is mandatory for the<br>server to reply in the exact same order as the requests were received.<br>这明显在性能上有明显的提升，因为连个请求之间的网络延迟被消灭了。许多http代理不能正确的支持pipelining，因为他们没有办法把响应和正确的请求联系起来。因为这个原因，服务器必须按照请求的顺序进行响应。</pre><br><pre>By default HAProxy operates in keep-alive mode with regards to persistent<br>connections: for each connection it processes each request and response, and<br>leaves the connection idle on both sides between the end of a response and the<br>start of a new request.</pre><br><pre>haproxy默认使用的时keep-alive的模式：对于每一个链接，它接受一个请求就处理一个请求，链接会在结束响应之后和新开始一个请求之间的时间内处于空闲。</pre><br><pre>HAProxy supports 5 connection modes :<br>  - keep alive    : all requests and responses are processed (default)<br>  - tunnel        : only the first request and response are processed,<br>                    everything else is forwarded with no analysis.<br>  - passive close : tunnel with “Connection: close” added in both directions.<br>  - server close  : the server-facing connection is closed after the response.<br>  - forced close  : the connection is actively closed after end of response.</pre><br><pre>haproxy支持5种链接模式</pre><br><pre>-keep alive:所已有的请求和响应都会被处理</pre><br><pre>-tunnel     :只有第一个请求和响应会被处理，其余的直接转发，不会被分析</pre><br><pre>-passive close：tunnel with “connection：close” added in both directions</pre><br><pre>-server close：the server-facing connection is closed after the response.</pre><br><pre>-forced close：在响应结束后链接会被关闭</pre><br></div><br><a id="1.2" name="1.2"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2" target="_blank" rel="external">1.2.</a></small> HTTP request<br><br><div><br><pre>First, let’s consider this HTTP request :<br><br>  Line     Contents<br>  number<br>     1     GET /serv/login.php?lang=en&amp;profile=2 HTTP/1.1<br>     2     Host: www.mydomain.com<br>     3     User-agent: my small browser<br>     4     Accept: image/jpeg, image/gif<br>     5     Accept: image/png</pre><br><pre>首先，我们来考虑下HTTP请求：</pre><br><pre>  Line     Contents<br>  number<br>     1     GET /serv/login.php?lang=en&amp;profile=2 HTTP/1.1<br>     2     Host: www.mydomain.com<br>     3     User-agent: my small browser<br>     4     Accept: image/jpeg, image/gif<br>     5     Accept: image/png</pre><br></div><br><a id="1.2.1" name="1.2.1"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2.1" target="_blank" rel="external">1.2.1.</a></small> The Request line<br><br><div><br><pre>Line 1 is the “request line”. It is always composed of 3 fields :<br>第一行时请求行，一般由三个部分组成<br>  - a METHOD      : GET<br>  - a URI         : /serv/login.php?lang=en&amp;profile=2<br>  - a version tag : HTTP/1.1<br><br>All of them are delimited by what the standard calls LWS (linear white spaces),<br>which are commonly spaces, but can also be tabs or line feeds/carriage returns<br>followed by spaces/tabs. The method itself cannot contain any colon (‘:’) and<br>is limited to alphabetic letters. All those various combinations make it<br>desirable that HAProxy performs the splitting itself rather than leaving it to<br>the user to write a complex or inaccurate regular expression.<br>这些都被叫做LWS（Linear white spaces，其实一般就是空格）的标准分割开。</pre><br><pre>方法：不能有任何的冒号，它被限制在字母表中的字符。</pre><br><pre>所有的这些不同组合在一起，可以让haproxy分析它，而不是让用户写复杂的正则表达式。</pre><br><pre>The URI itself can have several forms :<br><br>  - A “relative URI” :<br><br>      /serv/login.php?lang=en&amp;profile=2<br><br>    It is a complete URL without the host part. This is generally what is<br>    received by servers, reverse proxies and transparent proxies.<br><br>  - An “absolute URI”, also called a “URL” :<br><br>      <a href="http://192.168.0.12:8080/serv/login.php?lang=en&amp;profile=2" target="_blank" rel="external">http://192.168.0.12:8080/serv/login.php?lang=en&amp;profile=2</a><br><br>    It is composed of a “scheme” (the protocol name followed by ‘://‘), a host<br>    name or address, optionally a colon (‘:’) followed by a port number, then<br>    a relative URI beginning at the first slash (‘/‘) after the address part.<br>    This is generally what proxies receive, but a server supporting HTTP/1.1<br>    must accept this form too.<br>URI：有两种格式</pre><br><pre>第一种时相对路径的URI，如下</pre><br><pre>/serv/login.php?lang=en&amp;profile=2</pre><br><pre>这种是不需要域名部分的，这一般都是服务器/反向代理/透明代理接受到的样子</pre><br><pre>还有一种时绝对路径叫做URL，如下</pre><br><pre><a href="http://xxx.com/serv/login.php?lang=en&amp;profile=2" target="_blank" rel="external">http://xxx.com/serv/login.php?lang=en&amp;profile=2</a></pre><br><pre>这被一个scheme压缩（协议名字在://前面）</pre><br><pre>  - a star (‘*’) : this form is only accepted in association with the OPTIONS<br>    method and is not relayable. It is used to inquiry a next hop’s<br>    capabilities.<br><br>  - an address:port combination : 192.168.0.12:80<br>    This is used with the CONNECT method, which is used to establish TCP<br>    tunnels through HTTP proxies, generally for HTTPS, but sometimes for<br>    other protocols too.<br><br>In a relative URI, two sub-parts are identified. The part before the question<br>mark is called the “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#path" target="_blank" rel="external">path</a>“. It is typically the relative path to static objects<br>on the server. The part after the question mark is called the “query string”.<br>It is mostly used with GET requests sent to dynamic scripts and is very<br>specific to the language, framework or application in use.</pre><br></div><br><a id="1.2.2" name="1.2.2"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.2.2" target="_blank" rel="external">1.2.2.</a></small> The request headers<br><br><div><br><pre>The headers start at the second line. They are composed of a name at the<br>beginning of the line, immediately followed by a colon (‘:’). Traditionally,<br>an LWS is added after the colon but that’s not required. Then come the values.<br>Multiple identical headers may be folded into one single line, delimiting the<br>values with commas, provided that their order is respected. This is commonly<br>encountered in the “Cookie:” field. A header may span over multiple lines if<br>the subsequent lines begin with an LWS. In the example in 1.2, lines 4 and 5<br>define a total of 3 values for the “Accept:” header.</pre><br><pre>请求头从第二行开始，都是由一个语法时name: value1,value2<br><br>Contrary to a common mis-conception, header names are not case-sensitive, and<br>their values are not either if they refer to other header names (such as the<br>“Connection:” header).</pre><br><pre>http头的名字都不是大小写敏感的，当它的值引用其他的头的名字时，也不大小写敏感</pre><br><pre>The end of the headers is indicated by the first empty line. People often say<br>that it’s a double line feed, which is not exact, even if a double line feed<br>is one valid form of empty line.<br>头的结束时有一个空的行来表示</pre><br><pre>Fortunately, HAProxy takes care of all these complex combinations when indexing<br>headers, checking values and counting them, so there is no reason to worry<br>about the way they could be written, but it is important not to accuse an<br>application of being buggy if it does unusual, valid things.<br>幸运的时，haprxy对这些复杂的组合都会认证的建索引，检查值和对他们进行计数。<br>Important note:<br>   As suggested by RFC2616, HAProxy normalizes headers by replacing line breaks<br>   in the middle of headers by LWS in order to join multi-line headers. This<br>   is necessary for proper analysis and helps less capable HTTP parsers to work<br>   correctly and not to be fooled by such complex constructs.</pre><br></div><br><a id="1.3" name="1.3"></a><br><br>## <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3" target="_blank" rel="external">1.3.</a></small> HTTP response<br><br><div><br><pre>An HTTP response looks very much like an HTTP request. Both are called HTTP<br>messages. Let’s consider this HTTP response :<br>一个http响应比较像http的请求，都叫做http消息<br>  Line     Contents<br>  number<br>     1     HTTP/1.1 200 OK<br>     2     Content-length: 350<br>     3     Content-Type: text/html<br><br>As a special case, HTTP supports so called “Informational responses” as status<br>codes 1xx. These messages are special in that they don’t convey any part of the<br>response, they’re just used as sort of a signaling message to ask a client to<br>continue to post its request for instance. In the case of a status 100 response<br>the requested information will be carried by the next non-100 response message<br>following the informational one. This implies that multiple responses may be<br>sent to a single request, and that this only works when keep-alive is enabled<br>(1xx messages are HTTP/1.1 only). HAProxy handles these messages and is able to<br>correctly forward and skip them, and only process the next non-100 response. As<br>such, these messages are neither logged nor transformed, unless explicitly<br>state otherwise. Status 101 messages indicate that the protocol is changing<br>over the same connection and that haproxy must switch to tunnel mode, just as<br>if a CONNECT had occurred. Then the Upgrade header would contain additional<br>information about the type of protocol the connection is switching to.</pre><br></div><br><a id="1.3.1" name="1.3.1"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3.1" target="_blank" rel="external">1.3.1.</a></small> The Response line<br><br><div><br><pre>Line 1 is the “response line”. It is always composed of 3 fields :<br><br>  - a version tag : HTTP/1.1<br>  - a status code : 200<br>  - a reason      : OK<br><br>The status code is always 3-digit. The first digit indicates a general status :<br> - 1xx = informational message to be skipped (eg: 100, 101)<br> - 2xx = OK, content is following   (eg: 200, 206)<br> - 3xx = OK, no content following   (eg: 302, 304)<br> - 4xx = error caused by the client (eg: 401, 403, 404)<br> - 5xx = error caused by the server (eg: 500, 502, 503)<br><br>Please refer to RFC2616 for the detailed meaning of all such codes. The<br>“reason” field is just a hint, but is not parsed by clients. Anything can be<br>found there, but it’s a common practice to respect the well-established<br>messages. It can be composed of one or multiple words, such as “OK”, “Found”,<br>or “Authentication Required”.<br><br>Haproxy may emit the following status codes by itself :<br><br>  Code  When / reason<br>   200  access to stats page, and when replying to monitoring requests<br>   301  when performing a redirection, depending on the configured code<br>   302  when performing a redirection, depending on the configured code<br>   303  when performing a redirection, depending on the configured code<br>   307  when performing a redirection, depending on the configured code<br>   308  when performing a redirection, depending on the configured code<br>   400  for an invalid or too large request<br>   401  when an authentication is required to perform the action (when<br>        accessing the stats page)<br>   403  when a request is forbidden by a “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#block" target="_blank" rel="external">block</a>“ ACL or “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#reqdeny" target="_blank" rel="external">reqdeny</a>“ filter<br>   408  when the request timeout strikes before the request is complete<br>   500  when haproxy encounters an unrecoverable internal error, such as a<br>        memory allocation failure, which should never happen<br>   502  when the server returns an empty, invalid or incomplete response, or<br>        when an “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#rspdeny" target="_blank" rel="external">rspdeny</a>“ filter blocks the response.<br>   503  when no server was available to handle the request, or in response to<br>        monitoring requests which match the “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#monitor%20fail" target="_blank" rel="external">monitor fail</a>“ condition<br>   504  when the response timeout strikes before the server responds<br><br>The error 4xx and 5xx codes above may be customized (see “<a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#errorloc" target="_blank" rel="external">errorloc</a>“ in section<br>4.2).</pre><br></div><br><a id="1.3.2" name="1.3.2"></a><br><br>### <small><a href="http://cbonte.github.io/haproxy-dconv/configuration-1.6.html#1.3.2" target="_blank" rel="external">1.3.2.</a></small> The response headers<br><br><div><br><pre>Response headers work exactly like request headers, and as such, HAProxy uses<br>the same parsing function for both. Please refer to paragraph 1.2.2 for more<br>details.</pre><br></div>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/03/30/ubuntu14-04-e5-8d-b8-e8-bd-bd-e8-be-93-e5-85-a5-e6-b3-95-e5-90-8e-e5-be-aa-e7-8e-af-e7-99-bb-e5-bd-95-e4-b8-80-e7-9b-b4-e8-b7-b3-e5-88-b0-e7-99-bb-e5-bd-95-e7-95-8c-e9-9d-a2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          UBUNTU14.04 卸载输入法后循环登录一直跳到登录界面
        
      </div>
    </a>
  
  
    <a href="/2015/01/16/haproxy-e7-ae-80-e5-8d-95-e4-bd-bf-e7-94-a8http-e7-bf-bb-e8-af-91-e8-87-aadigitalocean/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">haproxy简单使用http-翻译自digitalocean</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="http-e5-8d-8f-e8-ae-ae" data-title="http协议" data-url="http://royzhao.github.io/2015/01/19/http-e5-8d-8f-e8-ae-ae/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 培龙
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>